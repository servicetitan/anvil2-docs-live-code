import { jsx, jsxs } from 'react/jsx-runtime';
import { useContext, forwardRef, useRef, useState, useId, useCallback, useEffect } from 'react';
import { S as SvgClose } from './close-DZj38AEh.js';
import { c as cx } from './index-tZvMCc77.js';
import { T as Text } from './Text-kPA-VzsB.js';
import { B as Button } from './Button-92_FKAyV.js';
import { D as DialogContext } from './DrawerContext-D4tWTLVf.js';
import { useTrackingId } from './useTrackingId.js';
import { c as childrenToString } from './childrenToString-Bz9MqbHb.js';
import { a as ToastProvider, b as ToasterPopover, c as ToasterContent } from './Toaster-Dg7M4W4U.js';
import { u as useDialogTransitionStates, a as useKeyboardFocusables, b as useDialogScrollLock, c as useInitialFocus } from './useInitialFocus-Cl_Txu7W.js';
import { r as registerLayer, a as unregisterLayer, b as useOnClickOutside } from './useOnClickOutside-BDzuUjmY.js';
import { u as useMergeRefs } from './useMergeRefs-Dfmtq9cI.js';

import './Dialog.css';function useDialogContext() {
  const context = useContext(DialogContext);
  if (!context) {
    throw new Error(
      "useDialogContext must be used within a DialogContextProvider"
    );
  }
  return context;
}

const DialogCancelButton = forwardRef((props, ref) => {
  const { onClick, ...rest } = props;
  const { close } = useDialogContext();
  const data = {
    title: props.title,
    appearance: props.appearance,
    size: props.size,
    type: props.type
  };
  const trackingId = useTrackingId({
    name: "DialogCancelButton",
    data,
    hasOverride: !!props["data-tracking-id"]
  });
  const onClickHandler = (e) => {
    onClick?.(e);
    close();
  };
  return /* @__PURE__ */ jsx(
    Button,
    {
      "aria-label": "Close dialog",
      "data-anv": "dialog-cancel-button",
      "data-tracking-id": trackingId,
      onClick: onClickHandler,
      ref,
      ...rest
    }
  );
});
DialogCancelButton.displayName = "DialogCancelButton";

const dialog = "_dialog_17szu_2";
const container = "_container_17szu_20";
const content = "_content_17szu_33";
const header = "_header_17szu_40";
const footer = "_footer_17szu_60";
const closing = "_closing_17szu_76";
const large = "_large_17szu_82";
const fullscreen = "_fullscreen_17szu_82";
const sticky = "_sticky_17szu_102";
const styles = {
	dialog: dialog,
	container: container,
	content: content,
	header: header,
	"close-container": "_close-container_17szu_53",
	footer: footer,
	closing: closing,
	large: large,
	fullscreen: fullscreen,
	sticky: sticky,
	"close-button": "_close-button_17szu_108"
};

const DialogHeader = forwardRef(
  (props, ref) => {
    const { children, className, ...rest } = props;
    const data = {
      children: childrenToString(props.children)
    };
    const trackingId = useTrackingId({
      name: "Dialog",
      data,
      hasOverride: !!props["data-tracking-id"]
    });
    const headerClassNames = cx(className, styles["header"]);
    return /* @__PURE__ */ jsxs(
      "header",
      {
        className: headerClassNames,
        "data-anv": "dialog-header",
        "data-tracking-id": trackingId,
        ref,
        ...rest,
        children: [
          /* @__PURE__ */ jsx(Text, { variant: "headline", el: "h1", children }),
          /* @__PURE__ */ jsx("span", { className: styles["close-container"], children: /* @__PURE__ */ jsx(
            DialogCancelButton,
            {
              className: styles["close-button"],
              size: "small",
              appearance: "ghost",
              "aria-label": "Close dialog",
              icon: SvgClose
            }
          ) })
        ]
      }
    );
  }
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = forwardRef(
  (props, ref) => {
    const { children, className, sticky = false, ...rest } = props;
    const footerClassNames = cx(styles["footer"], className, {
      [styles["sticky"]]: sticky
    });
    return /* @__PURE__ */ jsx(
      "footer",
      {
        className: footerClassNames,
        "data-anv": "dialog-footer",
        ref,
        ...rest,
        children
      }
    );
  }
);
DialogFooter.displayName = "DialogFooter";

const DialogContent = forwardRef(
  (props, ref) => {
    const { children, className, ...rest } = props;
    const contentClassNames = cx(styles["content"], className);
    return /* @__PURE__ */ jsx(
      "div",
      {
        className: contentClassNames,
        "data-anv": "dialog-content",
        ref,
        ...rest,
        children
      }
    );
  }
);
DialogContent.displayName = "DialogContent";

const DialogElement = forwardRef(
  (props, ref) => {
    const {
      className,
      open = false,
      children,
      onOpen,
      onOpenChange,
      onClose,
      onKeyDown,
      fullScreen = false,
      disableCloseOnEscape = false,
      onClickOutside,
      disableCloseOnClickOutside = false,
      size,
      enableScrollChaining,
      onOpenAnimationStart,
      onOpenAnimationComplete,
      onCloseAnimationStart,
      onCloseAnimationComplete,
      initialFocusResolver,
      ...rest
    } = props;
    const elRef = useRef(null);
    const contentRef = useRef(null);
    const toasterRef = useRef(null);
    const [hasOpenPopover, setHasOpenPopover] = useState(false);
    const id = useId();
    const { state, isOpenOrOpening } = useDialogTransitionStates(elRef, open, {
      onOpenAnimationStart: useCallback(() => {
        onOpenAnimationStart?.();
      }, [onOpenAnimationStart]),
      onOpenAnimationComplete: useCallback(() => {
        onOpenAnimationComplete?.();
        onOpen?.();
      }, [onOpen, onOpenAnimationComplete]),
      onCloseAnimationStart: useCallback(() => {
        onCloseAnimationStart?.();
      }, [onCloseAnimationStart]),
      onCloseAnimationComplete: useCallback(() => {
        onCloseAnimationComplete?.();
      }, [onCloseAnimationComplete])
    });
    const initial = useRef(true);
    useEffect(() => {
      if (initial.current) {
        initial.current = false;
      } else {
        onOpenChange?.(isOpenOrOpening);
      }
    }, [id, onOpenChange, isOpenOrOpening]);
    const classNames = cx([styles["dialog"]], className, {
      [styles["closing"]]: state === "closing",
      [styles["fullscreen"]]: fullScreen,
      [styles["large"]]: size === "large"
    });
    const { focusables } = useKeyboardFocusables(contentRef, {
      observeChange: true
    });
    useDialogScrollLock({
      open: isOpenOrOpening,
      id,
      enableScrollChaining,
      elementRef: elRef
    });
    useEffect(() => {
      if (open) {
        registerLayer(id);
      } else {
        unregisterLayer(id);
      }
      return () => {
        unregisterLayer(id);
      };
    }, [open, id]);
    useOnClickOutside({
      onOutsidePress: (e) => {
        if (!open) return;
        onClickOutside?.(e);
      },
      targets: [
        contentRef.current,
        toasterRef.current
      ],
      onClose: () => {
        if (disableCloseOnClickOutside || !open) return;
        onClose?.();
      },
      layerId: id
    });
    const computeFocus = useCallback((focusables2) => {
      return focusables2.find(
        (focusable) => focusable.dataset.anv !== "dialog-cancel-button"
      ) || focusables2[0];
    }, []);
    useInitialFocus(elRef, {
      computeFocus: initialFocusResolver || computeFocus
    });
    const onKeyDownHandler = (e) => {
      onKeyDown?.(e);
      if (e.code === "Escape") {
        e.preventDefault();
        if (disableCloseOnEscape) return;
        if (hasOpenPopover) return;
        onClose?.();
        return;
      }
      if (e.code === "Tab") {
        if (e.shiftKey && e.target === focusables?.[0]) {
          e.preventDefault();
          focusables[focusables.length - 1]?.focus();
          return;
        }
        if (e.target === focusables?.[focusables.length - 1] && !e.shiftKey) {
          e.preventDefault();
          focusables[0].focus();
          return;
        }
      }
    };
    return (
      // dialog element does seem to be interactive on MDN guideline
      /* @__PURE__ */ jsxs(
        "dialog",
        {
          className: classNames,
          "data-anv": "dialog",
          "data-anv-scroll-chaining": enableScrollChaining,
          "data-anv-transition-state": state,
          ref: useMergeRefs([ref, elRef]),
          onKeyDown: onKeyDownHandler,
          ...rest,
          children: [
            /* @__PURE__ */ jsx(ToastProvider, { isDialogToaster: open, children: /* @__PURE__ */ jsx(ToasterPopover, { children: /* @__PURE__ */ jsx(ToasterContent, { id: "dialog-toaster", ref: toasterRef }) }) }),
            /* @__PURE__ */ jsx(
              DialogContext.Provider,
              {
                value: {
                  close: () => onClose?.(),
                  ref: elRef,
                  hasOpenPopover,
                  setHasOpenPopover
                },
                children: /* @__PURE__ */ jsx(
                  "section",
                  {
                    ref: contentRef,
                    className: styles["container"],
                    "data-open": open,
                    children
                  }
                )
              }
            )
          ]
        }
      )
    );
  }
);
DialogElement.displayName = "Dialog";
const Dialog = Object.assign(DialogElement, {
  /**
   * DialogHeader component for the header section of a Dialog.
   *
   * Features:
   * - Displays dialog title with headline typography
   * - Includes close button with proper accessibility
   * - Sticky positioning for long content
   * - Consistent spacing and styling
   * - Automatic focus management
   * - Automatic tracking ID generation for analytics
   *
   * @example
   * <Dialog.Header>Confirm Delete</Dialog.Header>
   */
  Header: DialogHeader,
  /**
   * DialogFooter component for the footer section of a Dialog.
   *
   * Features:
   * - Container for dialog action buttons
   * - Optional sticky positioning for long content
   * - Consistent spacing and alignment
   * - Right-aligned button layout by default
   * - Flexible content area for custom layouts
   *
   * @example
   * <Dialog.Footer sticky>
   *   <Dialog.CancelButton>Cancel</Dialog.CancelButton>
   *   <Button appearance="primary">Save</Button>
   * </Dialog.Footer>
   */
  Footer: DialogFooter,
  /**
   * DialogContent component for the main content area of a Dialog.
   *
   * Features:
   * - Main content container for dialog body
   * - Flexible height with overflow handling
   * - Consistent padding and spacing
   * - Responsive design
   * - Proper content scrolling for long content
   *
   * @example
   * <Dialog.Content>
   *   <p>This is the main content of the dialog.</p>
   * </Dialog.Content>
   */
  Content: DialogContent,
  /**
   * DialogCancelButton component for cancel/close actions in a Dialog.
   *
   * Features:
   * - Button that automatically closes the dialog when clicked
   * - Extends all Button component props and functionality
   * - Proper accessibility with close dialog semantics
   * - Automatic focus management
   * - Consistent styling with other dialog elements
   * - Automatic tracking ID generation for analytics
   *
   * @example
   * <Dialog.CancelButton appearance="ghost">Cancel</Dialog.CancelButton>
   */
  CancelButton: DialogCancelButton
});

export { Dialog as D, DialogCancelButton as a, DialogContent as b, DialogFooter as c, DialogHeader as d };
//# sourceMappingURL=Dialog-CxH4Vnbb.js.map
