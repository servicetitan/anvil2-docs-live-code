{"version":3,"file":"useOptionallyControlledState-DbDuos5L.js","sources":["../src/internal/hooks/useOptionallyControlledState/useOptionallyControlledState.ts"],"sourcesContent":["import { useState, useCallback, SetStateAction, Dispatch } from \"react\";\n\n/**\n * Props for the useOptionallyControlledState hook\n */\ntype UseOptionallyControlledStateProps<T> = {\n  /**\n   * The controlled value of the state.\n   * When provided, the component becomes controlled.\n   */\n  controlledValue?: T;\n  /**\n   * The default value of the state.\n   * Used when the component is uncontrolled.\n   */\n  defaultValue?: T;\n  /**\n   * A function that is called when the value changes.\n   * @param value The new value\n   */\n  onChange?: (value: T) => void;\n};\n\n/**\n * Custom hook for managing optionally controlled state.\n *\n * Features:\n * - Supports both controlled and uncontrolled state management\n * - Automatically switches between controlled and uncontrolled modes\n * - Provides consistent API regardless of control mode\n * - Handles onChange callbacks for both modes\n * - Uses useCallback for optimized setter function\n * - Supports generic types for flexible state values\n *\n * @param props - Configuration object containing controlled value, default value, and onChange callback\n * @returns Tuple containing current value and setter function\n */\n/**\n * Custom hook that manages state that can be either controlled or uncontrolled.\n *\n * This hook provides a unified interface for managing component state that can be\n * controlled externally or managed internally. It automatically detects whether\n * the component should be controlled based on the presence of a controlledValue.\n *\n * @param controlledValue - The controlled value (makes component controlled when provided)\n * @param defaultValue - The default value for uncontrolled mode\n * @param onChange - Callback function called when the value changes\n * @returns Tuple containing the current value and a setter function\n *\n * @example\n * const [value, setValue] = useOptionallyControlledState({\n *   controlledValue: props.value,\n *   defaultValue: 0,\n *   onChange: props.onChange\n * });\n */\nexport function useOptionallyControlledState<T>({\n  controlledValue,\n  defaultValue,\n  onChange,\n}: UseOptionallyControlledStateProps<T>): [\n  T,\n  Dispatch<SetStateAction<T | undefined>>,\n] {\n  const [internalValue, setInternalValue] = useState<T | undefined>(\n    defaultValue,\n  );\n\n  const isControlled = controlledValue !== undefined;\n  const value = isControlled ? controlledValue : internalValue;\n\n  const setValue = useCallback(\n    (newValue: SetStateAction<T | undefined>) => {\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n      if (typeof newValue === \"function\") {\n        onChange?.(\n          (newValue as (prevState: T | undefined) => T | undefined)(value) ??\n            (value as T),\n        );\n      } else {\n        onChange?.(newValue as T);\n      }\n    },\n    [isControlled, onChange, value],\n  );\n\n  return [value as T, setValue];\n}\n"],"names":[],"mappings":";;AAwDO,SAAS,4BAAA,CAAgC;AAAA,EAC9C,eAAA;AAAA,EACA,YAAA;AAAA,EACA;AACF,CAAA,EAGE;AACA,EAAA,MAAM,CAAC,aAAA,EAAe,gBAAgB,CAAA,GAAI,QAAA;AAAA,IACxC;AAAA,GACF;AAEA,EAAA,MAAM,eAAe,eAAA,KAAoB,MAAA;AACzC,EAAA,MAAM,KAAA,GAAQ,eAAe,eAAA,GAAkB,aAAA;AAE/C,EAAA,MAAM,QAAA,GAAW,WAAA;AAAA,IACf,CAAC,QAAA,KAA4C;AAC3C,MAAA,IAAI,CAAC,YAAA,EAAc;AACjB,QAAA,gBAAA,CAAiB,QAAQ,CAAA;AAAA,MAC3B;AACA,MAAA,IAAI,OAAO,aAAa,UAAA,EAAY;AAClC,QAAA,QAAA;AAAA,UACG,QAAA,CAAyD,KAAK,CAAA,IAC5D;AAAA,SACL;AAAA,MACF,CAAA,MAAO;AACL,QAAA,QAAA,GAAW,QAAa,CAAA;AAAA,MAC1B;AAAA,IACF,CAAA;AAAA,IACA,CAAC,YAAA,EAAc,QAAA,EAAU,KAAK;AAAA,GAChC;AAEA,EAAA,OAAO,CAAC,OAAY,QAAQ,CAAA;AAC9B;;;;"}