import { useState, useDeferredValue, useRef, useEffect, useLayoutEffect, useCallback } from 'react';

const SCROLL_THRESHOLD = 0.64;
function useInfiniteCombobox({
  query,
  queryInitialItems,
  initialItems = [],
  initialPage = 0,
  initialLoading = false,
  initialInputValue,
  defaultInputValue,
  initialSelectedItem,
  defaultSelectedItem,
  initialSelectedItems,
  defaultSelectedItems,
  updateOnInputValueChange = true,
  updateOnSelectedItemChange = true,
  updateOnSelectedItemsChange = true,
  queryOnFirstRender = false,
  shouldTriggerQuery: shouldTriggerQueryProp
}) {
  const [items, setItems] = useState(initialItems);
  const deferredItems = useDeferredValue(items);
  const [page, setPage] = useState(initialPage);
  const [loading, setLoading] = useState(initialLoading);
  const deferredLoading = useDeferredValue(loading);
  const [inputValue, setInputValue] = useState(
    initialInputValue ?? defaultInputValue ?? ""
  );
  const [selectedItem, setSelectedItem] = useState(
    initialSelectedItem ?? defaultSelectedItem ?? null
  );
  const [selectedItems, setSelectedItems] = useState(
    initialSelectedItems ?? defaultSelectedItems ?? []
  );
  const scrollerRef = useRef(null);
  const defaultShouldTriggerQuery = (element) => {
    const totalScrollHeight = element.scrollHeight - element.clientHeight;
    return element.scrollTop / totalScrollHeight > SCROLL_THRESHOLD;
  };
  const [triggerQueryCount, setTriggerQueryCount] = useState(0);
  const triggerQueryCountRef = useRef(0);
  const triggerQuery = () => {
    setTriggerQueryCount((x) => x + 1);
    triggerQueryCountRef.current += 1;
  };
  const [done, setDone] = useState(false);
  const firstRenderRef = useRef(true);
  const scrollTimeoutRef = useRef(false);
  const loadingRef = useRef(false);
  const setLoadingStateAndRef = (isLoading) => {
    setLoading(isLoading);
    loadingRef.current = isLoading;
  };
  const queryRetryCountRef = useRef(0);
  useEffect(() => {
    if (firstRenderRef.current && queryInitialItems) {
      setItems(queryInitialItems());
    }
    if (firstRenderRef.current && !queryOnFirstRender) {
      firstRenderRef.current = false;
      return;
    }
    setLoadingStateAndRef(true);
    const timeoutID = setTimeout(() => {
      if (triggerQueryCount < triggerQueryCountRef.current) return;
      query({
        page,
        inputValue,
        selectedItem,
        selectedItems
      }).then((res) => {
        queryRetryCountRef.current = 0;
        if (triggerQueryCount < triggerQueryCountRef.current) return;
        setLoadingStateAndRef(false);
        setPage((x) => x + 1);
        if (res == null || page > 0 && res.length === 0) {
          setDone(true);
        } else if (page === 0) {
          setItems(() => [...res]);
        } else {
          setItems((prevItems) => [...prevItems, ...res]);
        }
      }).catch(() => {
        queryRetryCountRef.current += 1;
        if (queryRetryCountRef.current > 7) {
          queryRetryCountRef.current = 0;
          return;
        } else {
          setTimeout(
            () => {
              triggerQuery();
            },
            2 ** queryRetryCountRef.current * 160
          );
        }
      });
    }, 160);
    return () => {
      clearTimeout(timeoutID);
    };
  }, [triggerQueryCount]);
  useLayoutEffect(() => {
    setTimeout(() => {
      if (scrollerRef.current && scrollerRef.current.scrollHeight > 0 && scrollerRef.current.clientHeight > 0 && scrollerRef.current.scrollHeight <= scrollerRef.current.clientHeight) {
        triggerQuery();
      }
    }, 160);
  }, [items]);
  const isEmpty = items.length === 0 && page === 0;
  const onStateChange = useCallback(
    (changes) => {
      if (isEmpty && "isOpen" in changes && changes.isOpen === true) {
        triggerQuery();
      }
      const inputValueShouldUpdate = updateOnInputValueChange && "inputValue" in changes;
      const selectedItemsShouldUpdate = updateOnSelectedItemsChange && "selectedItems" in changes && changes.selectedItems;
      const selectedItemShouldUpdate = updateOnSelectedItemChange && "selectedItem" in changes && changes.selectedItem !== void 0;
      if (inputValueShouldUpdate) {
        setInputValue(changes.inputValue ?? "");
      }
      if (selectedItemsShouldUpdate) {
        setSelectedItems(changes.selectedItems ?? []);
      }
      if (selectedItemShouldUpdate) {
        setSelectedItem(changes.selectedItem);
      }
      if (inputValueShouldUpdate || selectedItemsShouldUpdate || selectedItemShouldUpdate) {
        setPage(0);
        setDone(false);
        triggerQuery();
      }
    },
    [
      isEmpty,
      updateOnInputValueChange,
      updateOnSelectedItemsChange,
      updateOnSelectedItemChange
    ]
  );
  const onScroll = useCallback(
    (e) => {
      const element = e.currentTarget;
      if (!scrollTimeoutRef.current && !loadingRef.current) {
        setTimeout(() => {
          const shouldTriggerQuery = shouldTriggerQueryProp ?? defaultShouldTriggerQuery;
          if (shouldTriggerQuery(element) && !done) {
            triggerQuery();
          }
          scrollTimeoutRef.current = false;
        }, 40);
        scrollTimeoutRef.current = true;
      }
    },
    [done, shouldTriggerQueryProp]
  );
  return {
    comboboxProps: {
      items: deferredItems,
      loading: deferredLoading,
      initialInputValue,
      defaultInputValue,
      initialSelectedItem,
      defaultSelectedItem,
      initialSelectedItems,
      defaultSelectedItems,
      disableFilter: true,
      // assume the query will return a filtered/sorted list
      onStateChange
    },
    contentProps: {
      onScroll,
      scrollerRef
    }
  };
}

export { useInfiniteCombobox as u };
//# sourceMappingURL=useInfiniteCombobox-WcRgC9p6.js.map
