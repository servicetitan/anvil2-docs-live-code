import { useRef, useState, useEffect, useCallback } from 'react';

const useOpenCloseTransitionStates = (openProp, options = {
  durationMs: 0
}) => {
  const {
    onOpenAnimationStart,
    onCloseAnimationStart,
    onOpenAnimationComplete,
    onCloseAnimationComplete,
    durationMs
  } = options;
  const prevOpenProp = useRef(openProp);
  const [state, setState] = useState(
    openProp ? "open" : "closed"
  );
  useEffect(() => {
    if (prevOpenProp.current && !openProp) {
      setState("closing");
    } else if (!prevOpenProp.current && openProp) {
      setState("opening");
    } else {
      setState(openProp ? "opening" : "closed");
    }
    prevOpenProp.current = openProp;
  }, [openProp]);
  useEffect(() => {
    if (!durationMs) return;
    if (state === "open" || state === "closed") return;
    if (state === "opening") {
      onOpenAnimationStart?.();
    } else if (state === "closing") {
      onCloseAnimationStart?.();
    }
    const d = typeof durationMs === "function" ? durationMs() : durationMs;
    const timeout = setTimeout(() => {
      if (state === "opening") {
        setState("open");
        onOpenAnimationComplete?.();
      } else if (state === "closing") {
        setState("closed");
        onCloseAnimationComplete?.();
      }
    }, d);
    return () => {
      clearTimeout(timeout);
    };
  }, [
    state,
    onOpenAnimationComplete,
    onCloseAnimationComplete,
    onOpenAnimationStart,
    onCloseAnimationStart,
    durationMs
  ]);
  const beginClosing = useCallback(() => {
    setState("closing");
  }, []);
  return {
    state,
    beginClosing,
    isOpenOrOpening: state === "open" || state === "opening",
    isClosedOrClosing: state === "closed" || state === "closing"
  };
};

const WINDOW_PROPERTY_LAYER_STACK = "__ANVIL_LAYER_MANAGER__";
const getGlobalLayers = () => {
  if (typeof window === "undefined") {
    return [];
  }
  if (!window[WINDOW_PROPERTY_LAYER_STACK]) {
    window[WINDOW_PROPERTY_LAYER_STACK] = [];
  }
  return window[WINDOW_PROPERTY_LAYER_STACK];
};
const registerLayer = (id) => {
  const layers = getGlobalLayers();
  if (!layers.includes(id)) {
    layers.push(id);
  }
};
const unregisterLayer = (id) => {
  const layers = getGlobalLayers();
  const index = layers.indexOf(id);
  if (index !== -1) {
    layers.splice(index, 1);
  }
};
const isTopLayer = (id) => {
  const layers = getGlobalLayers();
  return layers[layers.length - 1] === id;
};

const useOnClickOutside = ({
  onOutsidePress,
  targets,
  onClose,
  disable,
  layerId
}) => {
  useEffect(() => {
    if (disable || typeof document === "undefined") return;
    let isClosable = false;
    const onMouseDownHandler = (e) => {
      let isTarget = false;
      const path = e.composedPath();
      for (const el of targets) {
        if (el && path.includes(el)) {
          isTarget = true;
          break;
        }
      }
      if (!isTarget) {
        if (!layerId || isTopLayer(layerId)) {
          onOutsidePress?.(e);
          isClosable = true;
        }
      }
    };
    const onMouseUpHandler = (e) => {
      if (!isClosable) return;
      let isTarget = false;
      const path = e.composedPath();
      for (const el of targets) {
        if (el && path.includes(el)) {
          isTarget = true;
          break;
        }
      }
      if (!isTarget) {
        if (!layerId || isTopLayer(layerId)) {
          onClose?.();
        }
      }
    };
    document.addEventListener("mousedown", onMouseDownHandler);
    document.addEventListener("mouseup", onMouseUpHandler);
    return () => {
      document.removeEventListener("mousedown", onMouseDownHandler);
      document.removeEventListener("mouseup", onMouseUpHandler);
    };
  }, [onClose, onOutsidePress, targets, disable, layerId]);
};

export { unregisterLayer as a, useOnClickOutside as b, registerLayer as r, useOpenCloseTransitionStates as u };
//# sourceMappingURL=useOnClickOutside-BDzuUjmY.js.map
