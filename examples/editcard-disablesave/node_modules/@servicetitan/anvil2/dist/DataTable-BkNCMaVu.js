import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { C as Chip } from './Chip-X2EwdZ97.js';
import { F as Flex } from './Flex-CjPHUTeq.js';
import * as React from 'react';
import { useRef, useState, useLayoutEffect, createContext, useContext, forwardRef, useCallback, useMemo, useEffect, memo as memo$1, Fragment as Fragment$1 } from 'react';
import { c as cx } from './index-tZvMCc77.js';
import { C as Checkbox } from './Checkbox-C5Qjq_tU.js';
import { B as Button } from './Button-92_FKAyV.js';
import { S as SvgChevronRight } from './chevron_right-BdpsxX7x.js';
import { I as Icon } from './Icon-BSuTVNaa.js';
import { S as SrOnly } from './SrOnly-CTsYSuby.js';
import { M as Menu } from './Menu-DUAfSImY.js';
import { P as Popover } from './Popover-CIPg_ZgX.js';
import { S as SearchField } from './SearchField-DrgNbG3I.js';
import { L as ListView } from './ListView-CZ5T8bR1.js';
import { u as useLayoutPropsUtil } from './useLayoutPropsUtil-BlIWftBb.js';
import './anvil-fonts.css';import './DataTable.css';/* empty css                     */
import { P as Pagination } from './Pagination-BHEEnNas.js';
import { S as Spinner } from './Spinner-xEFwsq8_.js';
import { u as useOptionallyControlledState } from './useOptionallyControlledState-DbDuos5L.js';

function createColumnHelper$1() {
  return function createColumn(id, column) {
    if (typeof id === "object" && "group" in id) {
      return { id: id.group, ...column };
    }
    return { id, ...column };
  };
}

const styles$e = {
	"table-header-cell": "_table-header-cell_1ffr7_2",
	"table-body-cell": "_table-body-cell_1ffr7_3",
	"table-footer-cell": "_table-footer-cell_1ffr7_4",
	"last-pinned-left-column": "_last-pinned-left-column_1ffr7_33",
	"first-pinned-right-column": "_first-pinned-right-column_1ffr7_33",
	"empty-cell": "_empty-cell_1ffr7_54",
	"table-cell-internal-select": "_table-cell-internal-select_1ffr7_71",
	"table-cell-internal-expand": "_table-cell-internal-expand_1ffr7_72",
	"table-header-cell-group": "_table-header-cell-group_1ffr7_91",
	"table-header-cell-sortable": "_table-header-cell-sortable_1ffr7_100"};

const TableEmptyCellContent = () => {
  return /* @__PURE__ */ jsx("span", { "aria-label": "empty table cell", className: styles$e["empty-cell"], children: "—" });
};

const styles$d = {
	"truncate-chips": "_truncate-chips_1lgyk_2"
};

const TruncateChips = ({
  items = [],
  className,
  ...rest
}) => {
  const containerRef = useRef(null);
  const chipsContainerRef = useRef(null);
  const [hiddenCount, setHiddenCount] = useState(0);
  const hiddenChips = useRef([]);
  const plusChipRef = useRef(null);
  const [plusChipWidth, setPlusChipWidth] = useState(0);
  useLayoutEffect(() => {
    if (!chipsContainerRef.current) return;
    let totalHiddenCount = 0;
    const observer = new IntersectionObserver(
      (entries) => {
        const isResizing = document.querySelector(
          '[aria-label="Resize column"][aria-pressed="true"]'
        );
        if (isResizing) return;
        entries.forEach((entry) => {
          const target = entry.target;
          if (entry.isIntersecting) {
            target.style.display = "flex";
            target.style.visibility = "visible";
            totalHiddenCount = Math.max(0, totalHiddenCount - 1);
          }
          if (!entry.isIntersecting) {
            hiddenChips.current.push({
              el: target,
              rect: target.getBoundingClientRect()
            });
            target.style.visibility = "hidden";
            target.style.display = "none";
            totalHiddenCount++;
          }
        });
        setHiddenCount(totalHiddenCount);
      },
      {
        root: containerRef.current,
        rootMargin: "0px",
        threshold: 1
      }
    );
    const children = Array.from(chipsContainerRef.current.children);
    children.forEach((child) => {
      observer.observe(child);
    });
    return () => {
      observer.disconnect();
    };
  }, [items]);
  useLayoutEffect(() => {
    if (!containerRef.current) return;
    const observer = new ResizeObserver((entries) => {
      const entry = entries[entries.length - 1];
      if (entry) {
        if (hiddenCount > 0 && containerRef.current) {
          const plusChipRect = plusChipRef.current?.getBoundingClientRect();
          setPlusChipWidth(plusChipRect?.width ?? 0);
          const containerRect = containerRef.current.getBoundingClientRect();
          const chipRect = hiddenChips.current[hiddenChips.current.length - 1].rect;
          const fitsHorizontally = chipRect.width <= containerRect.width && chipRect.left >= containerRect.left && chipRect.right <= containerRect.right;
          const fitsVertically = chipRect.height <= containerRect.height && chipRect.top >= containerRect.top && chipRect.bottom <= containerRect.bottom;
          const hasEnoughSpace = fitsHorizontally && fitsVertically;
          hiddenChips.current[hiddenCount - 1].el.style.display = hasEnoughSpace ? "flex" : "none";
          if (hasEnoughSpace) {
            hiddenChips.current.pop();
          }
        }
      }
    });
    observer.observe(containerRef.current);
    return () => {
      observer.disconnect();
    };
  }, [hiddenCount]);
  return /* @__PURE__ */ jsxs(
    "div",
    {
      ref: containerRef,
      className: cx(styles$d["truncate-chips"], className),
      style: {
        marginInlineEnd: plusChipWidth
      },
      ...rest,
      children: [
        /* @__PURE__ */ jsx("div", { ref: chipsContainerRef, style: { display: "contents" }, children: items.map((chip, index) => /* @__PURE__ */ jsx(Chip, { ...chip, style: { visibility: "hidden" } }, index)) }),
        hiddenCount > 0 && /* @__PURE__ */ jsx(Chip, { label: `+${hiddenCount}`, ref: plusChipRef })
      ]
    }
  );
};

const chipsFormatter = (value, { truncateChips } = { truncateChips: false }) => {
  if (!value) return /* @__PURE__ */ jsx(TableEmptyCellContent, {});
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return /* @__PURE__ */ jsx(TableEmptyCellContent, {});
    }
    if (value.every((v) => typeof v === "string")) {
      if (truncateChips) {
        const items = value.map((v) => ({ label: v }));
        return /* @__PURE__ */ jsx(TruncateChips, { items });
      }
      return /* @__PURE__ */ jsx(Flex, { direction: "row", gap: "2", children: value.map((v) => /* @__PURE__ */ jsx(Chip, { label: v }, v)) });
    }
    if (truncateChips) {
      return /* @__PURE__ */ jsx(TruncateChips, { items: value });
    }
    return /* @__PURE__ */ jsx(Flex, { direction: "row", gap: "2", wrap: "wrap", children: value.map((v) => /* @__PURE__ */ jsx(Chip, { ...v }, v.label)) });
  }
  if (typeof value === "string") {
    return /* @__PURE__ */ jsx(Chip, { label: value });
  }
  return /* @__PURE__ */ jsx(Chip, { ...value });
};

const currencyFormatter = (value, { locale, currency } = {
  locale: "en-US",
  currency: "USD"
}) => {
  return value ? value.toLocaleString(locale, {
    style: "currency",
    currency
  }) : null;
};

const percentFormatter = (value, { decimals, locale } = {
  decimals: 2,
  locale: "en-US"
}) => {
  return value ? value.toLocaleString(locale, {
    style: "percent",
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals
  }) : null;
};

/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
// type Person = {
//   firstName: string
//   lastName: string
//   age: number
//   visits: number
//   status: string
//   progress: number
//   createdAt: Date
//   nested: {
//     foo: [
//       {
//         bar: 'bar'
//       }
//     ]
//     bar: { subBar: boolean }[]
//     baz: {
//       foo: 'foo'
//       bar: {
//         baz: 'baz'
//       }
//     }
//   }
// }

// const test: DeepKeys<Person> = 'nested.foo.0.bar'
// const test2: DeepKeys<Person> = 'nested.bar'

// const helper = createColumnHelper<Person>()

// helper.accessor('nested.foo', {
//   cell: info => info.getValue(),
// })

// helper.accessor('nested.foo.0.bar', {
//   cell: info => info.getValue(),
// })

// helper.accessor('nested.bar', {
//   cell: info => info.getValue(),
// })

function createColumnHelper() {
  return {
    accessor: (accessor, column) => {
      return typeof accessor === 'function' ? {
        ...column,
        accessorFn: accessor
      } : {
        ...column,
        accessorKey: accessor
      };
    },
    display: column => column,
    group: column => column
  };
}

// Is this type a tuple?

// If this type is a tuple, what indices are allowed?

///

function functionalUpdate(updater, input) {
  return typeof updater === 'function' ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return updater => {
    instance.setState(old => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d) {
  return d instanceof Function;
}
function isNumberArray(d) {
  return Array.isArray(d) && d.every(val => typeof val === 'number');
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = subArr => {
    subArr.forEach(item => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return depArgs => {
    let depTime;
    if (opts.key && opts.debug) depTime = Date.now();
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug) resultTime = Date.now();
    result = fn(...newDeps);
    opts == null || opts.onChange == null || opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = ' ' + str;
          }
          return str;
        };
        console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function getMemoOptions(tableOptions, debugLevel, key, onChange) {
  return {
    debug: () => {
      var _tableOptions$debugAl;
      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
    },
    key: process.env.NODE_ENV === 'development' && key,
    onChange
  };
}

function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table, column, row, cell) => ({
      table,
      column,
      row,
      cell: cell,
      getValue: cell.getValue,
      renderValue: cell.renderValue
    }), getMemoOptions(table.options, 'debugCells', 'cell.getContext'))
  };
  table._features.forEach(feature => {
    feature.createCell == null || feature.createCell(cell, column, row, table);
  }, {});
  return cell;
}

function createColumn(table, columnDef, depth, parent) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === 'function' ? accessorKey.replaceAll('.', '_') : accessorKey.replace(/\./g, '_') : undefined) != null ? _ref : typeof resolvedColumnDef.header === 'string' ? resolvedColumnDef.header : undefined;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    // Support deep accessor keys
    if (accessorKey.includes('.')) {
      accessorFn = originalRow => {
        let result = originalRow;
        for (const key of accessorKey.split('.')) {
          var _result;
          result = (_result = result) == null ? void 0 : _result[key];
          if (process.env.NODE_ENV !== 'production' && result === undefined) {
            console.warn(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
          }
        }
        return result;
      };
    } else {
      accessorFn = originalRow => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id) {
    if (process.env.NODE_ENV !== 'production') {
      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
    }
    throw new Error();
  }
  let column = {
    id: `${String(id)}`,
    accessorFn,
    parent: parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(d => d.getFlatColumns()))];
    }, getMemoOptions(table.options, 'debugColumns', 'column.getFlatColumns')),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], orderColumns => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap(column => column.getLeafColumns());
        return orderColumns(leafColumns);
      }
      return [column];
    }, getMemoOptions(table.options, 'debugColumns', 'column.getLeafColumns'))
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column, table);
  }

  // Yes, we have to convert table to unknown, because we know more than the compiler here.
  return column;
}

const debug = 'debugHeaders';
//

function createHeader(table, column, options) {
  var _options$id;
  const id = (_options$id = options.id) != null ? _options$id : column.id;
  let header = {
    id,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = h => {
        if (h.subHeaders && h.subHeaders.length) {
          h.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header: header,
      column
    })
  };
  table._features.forEach(feature => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
const Headers = {
  createTable: table => {
    // Header Groups

    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      var _left$map$filter, _right$map$filter;
      const leftColumns = (_left$map$filter = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
      const rightColumns = (_right$map$filter = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
      const centerColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
      return headerGroups;
    }, getMemoOptions(table.options, debug, 'getHeaderGroups'));
    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      leafColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      return buildHeaderGroups(allColumns, leafColumns, table, 'center');
    }, getMemoOptions(table.options, debug, 'getCenterHeaderGroups'));
    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
      var _left$map$filter2;
      const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'left');
    }, getMemoOptions(table.options, debug, 'getLeftHeaderGroups'));
    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
      var _right$map$filter2;
      const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'right');
    }, getMemoOptions(table.options, debug, 'getRightHeaderGroups'));

    // Footer Groups

    table.getFooterGroups = memo(() => [table.getHeaderGroups()], headerGroups => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, 'getFooterGroups'));
    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], headerGroups => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, 'getLeftFooterGroups'));
    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], headerGroups => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, 'getCenterFooterGroups'));
    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], headerGroups => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, 'getRightFooterGroups'));

    // Flat Headers

    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], headerGroups => {
      return headerGroups.map(headerGroup => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, 'getFlatHeaders'));
    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], left => {
      return left.map(headerGroup => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, 'getLeftFlatHeaders'));
    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], left => {
      return left.map(headerGroup => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, 'getCenterFlatHeaders'));
    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], left => {
      return left.map(headerGroup => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, 'getRightFlatHeaders'));

    // Leaf Headers

    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], flatHeaders => {
      return flatHeaders.filter(header => {
        var _header$subHeaders;
        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
      });
    }, getMemoOptions(table.options, debug, 'getCenterLeafHeaders'));
    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], flatHeaders => {
      return flatHeaders.filter(header => {
        var _header$subHeaders2;
        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
      });
    }, getMemoOptions(table.options, debug, 'getLeftLeafHeaders'));
    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], flatHeaders => {
      return flatHeaders.filter(header => {
        var _header$subHeaders3;
        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
      });
    }, getMemoOptions(table.options, debug, 'getRightLeafHeaders'));
    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
      return [...((_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : []), ...((_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : []), ...((_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : [])].map(header => {
        return header.getLeafHeaders();
      }).flat();
    }, getMemoOptions(table.options, debug, 'getLeafHeaders'));
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  // Find the max depth of the columns:
  // build the leaf column row
  // build each buffer row going up
  //    placeholder for non-existent level
  //    real column for existing level

  let maxDepth = 0;
  const findMaxDepth = function (columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter(column => column.getIsVisible()).forEach(column => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    // The header group we are creating
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join('_'),
      headers: []
    };

    // The parent columns we're going to scan next
    const pendingParentHeaders = [];

    // Scan each column for parents
    headersToGroup.forEach(headerToGroup => {
      // What is the latest (last) parent column?

      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        // The parent header is new
        column = headerToGroup.column.parent;
      } else {
        // The parent header is repeated
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        // This column is repeated. Add it as a sub header to the next batch
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        // This is a new header. Let's create it
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join('_'),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter(d => d.column === column).length}` : undefined,
          depth,
          index: pendingParentHeaders.length
        });

        // Add the headerToGroup as a subHeader of the new header
        header.subHeaders.push(headerToGroup);
        // Add the new header to the pendingParentHeaders to get grouped
        // in the next batch
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {
    depth: maxDepth,
    index
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();

  // headerGroups = headerGroups.filter(headerGroup => {
  //   return !headerGroup.headers.every(header => header.isPlaceholder)
  // })

  const recurseHeadersForSpans = headers => {
    const filteredHeaders = headers.filter(header => header.column.getIsVisible());
    return filteredHeaders.map(header => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach(_ref => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}

const createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: columnId => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return undefined;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: columnId => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return undefined;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: columnId => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: subRows != null ? subRows : [],
    getLeafRows: () => flattenBy(row.subRows, d => d.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : undefined,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow) break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo(() => [table.getAllLeafColumns()], leafColumns => {
      return leafColumns.map(column => {
        return createCell(table, row, column, column.id);
      });
    }, getMemoOptions(table.options, 'debugRows', 'getAllCells')),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], allCells => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, getMemoOptions(table.options, 'debugRows', 'getAllCellsByColumnId'))
  };
  for (let i = 0; i < table._features.length; i++) {
    const feature = table._features[i];
    feature == null || feature.createRow == null || feature.createRow(row, table);
  }
  return row;
};

//

const ColumnFaceting = {
  createColumn: (column, table) => {
    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);
    column.getFacetedRowModel = () => {
      if (!column._getFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return column._getFacetedRowModel();
    };
    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);
    column.getFacetedUniqueValues = () => {
      if (!column._getFacetedUniqueValues) {
        return new Map();
      }
      return column._getFacetedUniqueValues();
    };
    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);
    column.getFacetedMinMaxValues = () => {
      if (!column._getFacetedMinMaxValues) {
        return undefined;
      }
      return column._getFacetedMinMaxValues();
    };
  }
};

const includesString = (row, columnId, filterValue) => {
  var _filterValue$toString, _row$getValue;
  const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
};
includesString.autoRemove = val => testFalsey(val);
const includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = val => testFalsey(val);
const equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = val => testFalsey(val);
const arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = val => testFalsey(val);
const arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some(val => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = val => testFalsey(val) || !(val != null && val.length);
const arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some(val => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = val => testFalsey(val) || !(val != null && val.length);
const equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = val => testFalsey(val);
const weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = val => testFalsey(val);
const inNumberRange = (row, columnId, filterValue) => {
  let [min, max] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min && rowValue <= max;
};
inNumberRange.resolveFilterValue = val => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== 'number' ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== 'number' ? parseFloat(unsafeMax) : unsafeMax;
  let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min > max) {
    const temp = min;
    min = max;
    max = temp;
  }
  return [min, max];
};
inNumberRange.autoRemove = val => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);

// Export

const filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
// Utils

function testFalsey(val) {
  return val === undefined || val === null || val === '';
}

//

const ColumnFiltering = {
  getDefaultColumnDef: () => {
    return {
      filterFn: 'auto'
    };
  },
  getInitialState: state => {
    return {
      columnFilters: [],
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onColumnFiltersChange: makeStateUpdater('columnFilters', table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100
    };
  },
  createColumn: (column, table) => {
    column.getAutoFilterFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === 'string') {
        return filterFns.includesString;
      }
      if (typeof value === 'number') {
        return filterFns.inNumberRange;
      }
      if (typeof value === 'boolean') {
        return filterFns.equals;
      }
      if (value !== null && typeof value === 'object') {
        return filterFns.equals;
      }
      if (Array.isArray(value)) {
        return filterFns.arrIncludes;
      }
      return filterFns.weakEquals;
    };
    column.getFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === 'auto' ? column.getAutoFilterFn() : // @ts-ignore
      (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];
    };
    column.getCanFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
    };
    column.getIsFiltered = () => column.getFilterIndex() > -1;
    column.getFilterValue = () => {
      var _table$getState$colum;
      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find(d => d.id === column.id)) == null ? void 0 : _table$getState$colum.value;
    };
    column.getFilterIndex = () => {
      var _table$getState$colum2, _table$getState$colum3;
      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex(d => d.id === column.id)) != null ? _table$getState$colum2 : -1;
    };
    column.setFilterValue = value => {
      table.setColumnFilters(old => {
        const filterFn = column.getFilterFn();
        const previousFilter = old == null ? void 0 : old.find(d => d.id === column.id);
        const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : undefined);

        //
        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
          var _old$filter;
          return (_old$filter = old == null ? void 0 : old.filter(d => d.id !== column.id)) != null ? _old$filter : [];
        }
        const newFilterObj = {
          id: column.id,
          value: newFilter
        };
        if (previousFilter) {
          var _old$map;
          return (_old$map = old == null ? void 0 : old.map(d => {
            if (d.id === column.id) {
              return newFilterObj;
            }
            return d;
          })) != null ? _old$map : [];
        }
        if (old != null && old.length) {
          return [...old, newFilterObj];
        }
        return [newFilterObj];
      });
    };
  },
  createRow: (row, _table) => {
    row.columnFilters = {};
    row.columnFiltersMeta = {};
  },
  createTable: table => {
    table.setColumnFilters = updater => {
      const leafColumns = table.getAllLeafColumns();
      const updateFn = old => {
        var _functionalUpdate;
        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter(filter => {
          const column = leafColumns.find(d => d.id === filter.id);
          if (column) {
            const filterFn = column.getFilterFn();
            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {
              return false;
            }
          }
          return true;
        });
      };
      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
    };
    table.resetColumnFilters = defaultState => {
      var _table$initialState$c, _table$initialState;
      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
    };
    table.getPreFilteredRowModel = () => table.getCoreRowModel();
    table.getFilteredRowModel = () => {
      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
        table._getFilteredRowModel = table.options.getFilteredRowModel(table);
      }
      if (table.options.manualFiltering || !table._getFilteredRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getFilteredRowModel();
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === 'undefined' || typeof value === 'string' && !value;
}

const sum = (columnId, _leafRows, childRows) => {
  // It's faster to just add the aggregations together instead of
  // process leaf nodes individually
  return childRows.reduce((sum, next) => {
    const nextValue = next.getValue(columnId);
    return sum + (typeof nextValue === 'number' ? nextValue : 0);
  }, 0);
};
const min = (columnId, _leafRows, childRows) => {
  let min;
  childRows.forEach(row => {
    const value = row.getValue(columnId);
    if (value != null && (min > value || min === undefined && value >= value)) {
      min = value;
    }
  });
  return min;
};
const max = (columnId, _leafRows, childRows) => {
  let max;
  childRows.forEach(row => {
    const value = row.getValue(columnId);
    if (value != null && (max < value || max === undefined && value >= value)) {
      max = value;
    }
  });
  return max;
};
const extent = (columnId, _leafRows, childRows) => {
  let min;
  let max;
  childRows.forEach(row => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min === undefined) {
        if (value >= value) min = max = value;
      } else {
        if (min > value) min = value;
        if (max < value) max = value;
      }
    }
  });
  return [min, max];
};
const mean = (columnId, leafRows) => {
  let count = 0;
  let sum = 0;
  leafRows.forEach(row => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count, sum += value;
    }
  });
  if (count) return sum / count;
  return;
};
const median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values = leafRows.map(row => row.getValue(columnId));
  if (!isNumberArray(values)) {
    return;
  }
  if (values.length === 1) {
    return values[0];
  }
  const mid = Math.floor(values.length / 2);
  const nums = values.sort((a, b) => a - b);
  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
const unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map(d => d.getValue(columnId))).values());
};
const uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map(d => d.getValue(columnId))).size;
};
const count = (_columnId, leafRows) => {
  return leafRows.length;
};
const aggregationFns = {
  sum,
  min,
  max,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count
};

//

const ColumnGrouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: props => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: 'auto'
    };
  },
  getInitialState: state => {
    return {
      grouping: [],
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onGroupingChange: makeStateUpdater('grouping', table),
      groupedColumnMode: 'reorder'
    };
  },
  createColumn: (column, table) => {
    column.toggleGrouping = () => {
      table.setGrouping(old => {
        // Find any existing grouping for this column
        if (old != null && old.includes(column.id)) {
          return old.filter(d => d !== column.id);
        }
        return [...(old != null ? old : []), column.id];
      });
    };
    column.getCanGroup = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);
    };
    column.getIsGrouped = () => {
      var _table$getState$group;
      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
    };
    column.getGroupedIndex = () => {
      var _table$getState$group2;
      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
    };
    column.getToggleGroupingHandler = () => {
      const canGroup = column.getCanGroup();
      return () => {
        if (!canGroup) return;
        column.toggleGrouping();
      };
    };
    column.getAutoAggregationFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === 'number') {
        return aggregationFns.sum;
      }
      if (Object.prototype.toString.call(value) === '[object Date]') {
        return aggregationFns.extent;
      }
    };
    column.getAggregationFn = () => {
      var _table$options$aggreg, _table$options$aggreg2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === 'auto' ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
    };
  },
  createTable: table => {
    table.setGrouping = updater => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
    table.resetGrouping = defaultState => {
      var _table$initialState$g, _table$initialState;
      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
    };
    table.getPreGroupedRowModel = () => table.getFilteredRowModel();
    table.getGroupedRowModel = () => {
      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
        table._getGroupedRowModel = table.options.getGroupedRowModel(table);
      }
      if (table.options.manualGrouping || !table._getGroupedRowModel) {
        return table.getPreGroupedRowModel();
      }
      return table._getGroupedRowModel();
    };
  },
  createRow: (row, table) => {
    row.getIsGrouped = () => !!row.groupingColumnId;
    row.getGroupingValue = columnId => {
      if (row._groupingValuesCache.hasOwnProperty(columnId)) {
        return row._groupingValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.columnDef.getGroupingValue)) {
        return row.getValue(columnId);
      }
      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
      return row._groupingValuesCache[columnId];
    };
    row._groupingValuesCache = {};
  },
  createCell: (cell, column, row, table) => {
    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;
    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();
    cell.getIsAggregated = () => {
      var _row$subRows;
      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter(col => !grouping.includes(col.id));
  if (groupedColumnMode === 'remove') {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map(g => leafColumns.find(col => col.id === g)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}

//

const ColumnOrdering = {
  getInitialState: state => {
    return {
      columnOrder: [],
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onColumnOrderChange: makeStateUpdater('columnOrder', table)
    };
  },
  createColumn: (column, table) => {
    column.getIndex = memo(position => [_getVisibleLeafColumns(table, position)], columns => columns.findIndex(d => d.id === column.id), getMemoOptions(table.options, 'debugColumns', 'getIndex'));
    column.getIsFirstColumn = position => {
      var _columns$;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;
    };
    column.getIsLastColumn = position => {
      var _columns;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;
    };
  },
  createTable: table => {
    table.setColumnOrder = updater => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
    table.resetColumnOrder = defaultState => {
      var _table$initialState$c;
      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
    };
    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => columns => {
      // Sort grouped columns to the start of the column list
      // before the headers are built
      let orderedColumns = [];

      // If there is no order, return the normal columns
      if (!(columnOrder != null && columnOrder.length)) {
        orderedColumns = columns;
      } else {
        const columnOrderCopy = [...columnOrder];

        // If there is an order, make a copy of the columns
        const columnsCopy = [...columns];

        // And make a new ordered array of the columns

        // Loop over the columns and place them in order into the new array
        while (columnsCopy.length && columnOrderCopy.length) {
          const targetColumnId = columnOrderCopy.shift();
          const foundIndex = columnsCopy.findIndex(d => d.id === targetColumnId);
          if (foundIndex > -1) {
            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
          }
        }

        // If there are any columns left, add them to the end
        orderedColumns = [...orderedColumns, ...columnsCopy];
      }
      return orderColumns(orderedColumns, grouping, groupedColumnMode);
    }, getMemoOptions(table.options, 'debugTable', '_getOrderColumnsFn'));
  }
};

//

const getDefaultColumnPinningState = () => ({
  left: [],
  right: []
});
const ColumnPinning = {
  getInitialState: state => {
    return {
      columnPinning: getDefaultColumnPinningState(),
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onColumnPinningChange: makeStateUpdater('columnPinning', table)
    };
  },
  createColumn: (column, table) => {
    column.pin = position => {
      const columnIds = column.getLeafColumns().map(d => d.id).filter(Boolean);
      table.setColumnPinning(old => {
        var _old$left3, _old$right3;
        if (position === 'right') {
          var _old$left, _old$right;
          return {
            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter(d => !(columnIds != null && columnIds.includes(d))),
            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds]
          };
        }
        if (position === 'left') {
          var _old$left2, _old$right2;
          return {
            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds],
            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter(d => !(columnIds != null && columnIds.includes(d)))
          };
        }
        return {
          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter(d => !(columnIds != null && columnIds.includes(d))),
          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter(d => !(columnIds != null && columnIds.includes(d)))
        };
      });
    };
    column.getCanPin = () => {
      const leafColumns = column.getLeafColumns();
      return leafColumns.some(d => {
        var _d$columnDef$enablePi, _ref, _table$options$enable;
        return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
      });
    };
    column.getIsPinned = () => {
      const leafColumnIds = column.getLeafColumns().map(d => d.id);
      const {
        left,
        right
      } = table.getState().columnPinning;
      const isLeft = leafColumnIds.some(d => left == null ? void 0 : left.includes(d));
      const isRight = leafColumnIds.some(d => right == null ? void 0 : right.includes(d));
      return isLeft ? 'left' : isRight ? 'right' : false;
    };
    column.getPinnedIndex = () => {
      var _table$getState$colum, _table$getState$colum2;
      const position = column.getIsPinned();
      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
    };
  },
  createRow: (row, table) => {
    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
      const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];
      return allCells.filter(d => !leftAndRight.includes(d.column.id));
    }, getMemoOptions(table.options, 'debugRows', 'getCenterVisibleCells'));
    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left) => {
      const cells = (left != null ? left : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({
        ...d,
        position: 'left'
      }));
      return cells;
    }, getMemoOptions(table.options, 'debugRows', 'getLeftVisibleCells'));
    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
      const cells = (right != null ? right : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({
        ...d,
        position: 'right'
      }));
      return cells;
    }, getMemoOptions(table.options, 'debugRows', 'getRightVisibleCells'));
  },
  createTable: table => {
    table.setColumnPinning = updater => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
    table.resetColumnPinning = defaultState => {
      var _table$initialState$c, _table$initialState;
      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
    };
    table.getIsSomeColumnsPinned = position => {
      var _pinningState$positio;
      const pinningState = table.getState().columnPinning;
      if (!position) {
        var _pinningState$left, _pinningState$right;
        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
      return (left != null ? left : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, 'debugColumns', 'getLeftLeafColumns'));
    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
      return (right != null ? right : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, 'debugColumns', 'getRightLeafColumns'));
    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
      const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];
      return allColumns.filter(d => !leftAndRight.includes(d.id));
    }, getMemoOptions(table.options, 'debugColumns', 'getCenterLeafColumns'));
  }
};

function safelyAccessDocument(_document) {
  return _document || (typeof document !== 'undefined' ? document : null);
}

//

//

const defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
const getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
const ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: state => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      columnResizeMode: 'onEnd',
      columnResizeDirection: 'ltr',
      onColumnSizingChange: makeStateUpdater('columnSizing', table),
      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', table)
    };
  },
  createColumn: (column, table) => {
    column.getSize = () => {
      var _column$columnDef$min, _ref, _column$columnDef$max;
      const columnSize = table.getState().columnSizing[column.id];
      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
    };
    column.getStart = memo(position => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(0, column.getIndex(position)).reduce((sum, column) => sum + column.getSize(), 0), getMemoOptions(table.options, 'debugColumns', 'getStart'));
    column.getAfter = memo(position => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(column.getIndex(position) + 1).reduce((sum, column) => sum + column.getSize(), 0), getMemoOptions(table.options, 'debugColumns', 'getAfter'));
    column.resetSize = () => {
      table.setColumnSizing(_ref2 => {
        let {
          [column.id]: _,
          ...rest
        } = _ref2;
        return rest;
      });
    };
    column.getCanResize = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
    };
    column.getIsResizing = () => {
      return table.getState().columnSizingInfo.isResizingColumn === column.id;
    };
  },
  createHeader: (header, table) => {
    header.getSize = () => {
      let sum = 0;
      const recurse = header => {
        if (header.subHeaders.length) {
          header.subHeaders.forEach(recurse);
        } else {
          var _header$column$getSiz;
          sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;
        }
      };
      recurse(header);
      return sum;
    };
    header.getStart = () => {
      if (header.index > 0) {
        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
      }
      return 0;
    };
    header.getResizeHandler = _contextDocument => {
      const column = table.getColumn(header.column.id);
      const canResize = column == null ? void 0 : column.getCanResize();
      return e => {
        if (!column || !canResize) {
          return;
        }
        e.persist == null || e.persist();
        if (isTouchStartEvent(e)) {
          // lets not respond to multiple touches (e.g. 2 or 3 fingers)
          if (e.touches && e.touches.length > 1) {
            return;
          }
        }
        const startSize = header.getSize();
        const columnSizingStart = header ? header.getLeafHeaders().map(d => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];
        const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;
        const newColumnSizing = {};
        const updateOffset = (eventType, clientXPos) => {
          if (typeof clientXPos !== 'number') {
            return;
          }
          table.setColumnSizingInfo(old => {
            var _old$startOffset, _old$startSize;
            const deltaDirection = table.options.columnResizeDirection === 'rtl' ? -1 : 1;
            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
            old.columnSizingStart.forEach(_ref3 => {
              let [columnId, headerSize] = _ref3;
              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
            });
            return {
              ...old,
              deltaOffset,
              deltaPercentage
            };
          });
          if (table.options.columnResizeMode === 'onChange' || eventType === 'end') {
            table.setColumnSizing(old => ({
              ...old,
              ...newColumnSizing
            }));
          }
        };
        const onMove = clientXPos => updateOffset('move', clientXPos);
        const onEnd = clientXPos => {
          updateOffset('end', clientXPos);
          table.setColumnSizingInfo(old => ({
            ...old,
            isResizingColumn: false,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        };
        const contextDocument = safelyAccessDocument(_contextDocument);
        const mouseEvents = {
          moveHandler: e => onMove(e.clientX),
          upHandler: e => {
            contextDocument == null || contextDocument.removeEventListener('mousemove', mouseEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener('mouseup', mouseEvents.upHandler);
            onEnd(e.clientX);
          }
        };
        const touchEvents = {
          moveHandler: e => {
            if (e.cancelable) {
              e.preventDefault();
              e.stopPropagation();
            }
            onMove(e.touches[0].clientX);
            return false;
          },
          upHandler: e => {
            var _e$touches$;
            contextDocument == null || contextDocument.removeEventListener('touchmove', touchEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener('touchend', touchEvents.upHandler);
            if (e.cancelable) {
              e.preventDefault();
              e.stopPropagation();
            }
            onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);
          }
        };
        const passiveIfSupported = passiveEventSupported() ? {
          passive: false
        } : false;
        if (isTouchStartEvent(e)) {
          contextDocument == null || contextDocument.addEventListener('touchmove', touchEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener('touchend', touchEvents.upHandler, passiveIfSupported);
        } else {
          contextDocument == null || contextDocument.addEventListener('mousemove', mouseEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener('mouseup', mouseEvents.upHandler, passiveIfSupported);
        }
        table.setColumnSizingInfo(old => ({
          ...old,
          startOffset: clientX,
          startSize,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart,
          isResizingColumn: column.id
        }));
      };
    };
  },
  createTable: table => {
    table.setColumnSizing = updater => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
    table.setColumnSizingInfo = updater => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
    table.resetColumnSizing = defaultState => {
      var _table$initialState$c;
      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
    };
    table.resetHeaderSizeInfo = defaultState => {
      var _table$initialState$c2;
      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
    };
    table.getTotalSize = () => {
      var _table$getHeaderGroup, _table$getHeaderGroup2;
      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header) => {
        return sum + header.getSize();
      }, 0)) != null ? _table$getHeaderGroup : 0;
    };
    table.getLeftTotalSize = () => {
      var _table$getLeftHeaderG, _table$getLeftHeaderG2;
      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header) => {
        return sum + header.getSize();
      }, 0)) != null ? _table$getLeftHeaderG : 0;
    };
    table.getCenterTotalSize = () => {
      var _table$getCenterHeade, _table$getCenterHeade2;
      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header) => {
        return sum + header.getSize();
      }, 0)) != null ? _table$getCenterHeade : 0;
    };
    table.getRightTotalSize = () => {
      var _table$getRightHeader, _table$getRightHeader2;
      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header) => {
        return sum + header.getSize();
      }, 0)) != null ? _table$getRightHeader : 0;
    };
  }
};
let passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === 'boolean') return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop = () => {};
    window.addEventListener('test', noop, options);
    window.removeEventListener('test', noop);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e) {
  return e.type === 'touchstart';
}

//

const ColumnVisibility = {
  getInitialState: state => {
    return {
      columnVisibility: {},
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onColumnVisibilityChange: makeStateUpdater('columnVisibility', table)
    };
  },
  createColumn: (column, table) => {
    column.toggleVisibility = value => {
      if (column.getCanHide()) {
        table.setColumnVisibility(old => ({
          ...old,
          [column.id]: value != null ? value : !column.getIsVisible()
        }));
      }
    };
    column.getIsVisible = () => {
      var _ref, _table$getState$colum;
      const childColumns = column.columns;
      return (_ref = childColumns.length ? childColumns.some(c => c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;
    };
    column.getCanHide = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
    };
    column.getToggleVisibilityHandler = () => {
      return e => {
        column.toggleVisibility == null || column.toggleVisibility(e.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], cells => {
      return cells.filter(cell => cell.column.getIsVisible());
    }, getMemoOptions(table.options, 'debugRows', '_getAllVisibleCells'));
    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, 'debugRows', 'getVisibleCells'));
  },
  createTable: table => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter(d => d.getIsVisible()).map(d => d.id).join('_')], columns => {
        return columns.filter(d => d.getIsVisible == null ? void 0 : d.getIsVisible());
      }, getMemoOptions(table.options, 'debugColumns', key));
    };
    table.getVisibleFlatColumns = makeVisibleColumnsMethod('getVisibleFlatColumns', () => table.getAllFlatColumns());
    table.getVisibleLeafColumns = makeVisibleColumnsMethod('getVisibleLeafColumns', () => table.getAllLeafColumns());
    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod('getLeftVisibleLeafColumns', () => table.getLeftLeafColumns());
    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod('getRightVisibleLeafColumns', () => table.getRightLeafColumns());
    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod('getCenterVisibleLeafColumns', () => table.getCenterLeafColumns());
    table.setColumnVisibility = updater => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
    table.resetColumnVisibility = defaultState => {
      var _table$initialState$c;
      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
    };
    table.toggleAllColumnsVisible = value => {
      var _value;
      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
        ...obj,
        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
      }), {}));
    };
    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some(column => !(column.getIsVisible != null && column.getIsVisible()));
    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some(column => column.getIsVisible == null ? void 0 : column.getIsVisible());
    table.getToggleAllColumnsVisibilityHandler = () => {
      return e => {
        var _target;
        table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
function _getVisibleLeafColumns(table, position) {
  return !position ? table.getVisibleLeafColumns() : position === 'center' ? table.getCenterVisibleLeafColumns() : position === 'left' ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}

//

const GlobalFaceting = {
  createTable: table => {
    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, '__global__');
    table.getGlobalFacetedRowModel = () => {
      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getGlobalFacetedRowModel();
    };
    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, '__global__');
    table.getGlobalFacetedUniqueValues = () => {
      if (!table._getGlobalFacetedUniqueValues) {
        return new Map();
      }
      return table._getGlobalFacetedUniqueValues();
    };
    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, '__global__');
    table.getGlobalFacetedMinMaxValues = () => {
      if (!table._getGlobalFacetedMinMaxValues) {
        return;
      }
      return table._getGlobalFacetedMinMaxValues();
    };
  }
};

//

const GlobalFiltering = {
  getInitialState: state => {
    return {
      globalFilter: undefined,
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onGlobalFilterChange: makeStateUpdater('globalFilter', table),
      globalFilterFn: 'auto',
      getColumnCanGlobalFilter: column => {
        var _table$getCoreRowMode;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
        return typeof value === 'string' || typeof value === 'number';
      }
    };
  },
  createColumn: (column, table) => {
    column.getCanGlobalFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;
      return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
    };
  },
  createTable: table => {
    table.getGlobalAutoFilterFn = () => {
      return filterFns.includesString;
    };
    table.getGlobalFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      const {
        globalFilterFn: globalFilterFn
      } = table.options;
      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === 'auto' ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];
    };
    table.setGlobalFilter = updater => {
      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
    };
    table.resetGlobalFilter = defaultState => {
      table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);
    };
  }
};

//

const RowExpanding = {
  getInitialState: state => {
    return {
      expanded: {},
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onExpandedChange: makeStateUpdater('expanded', table),
      paginateExpandedRows: true
    };
  },
  createTable: table => {
    let registered = false;
    let queued = false;
    table._autoResetExpanded = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetExpanded();
          queued = false;
        });
      }
    };
    table.setExpanded = updater => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
    table.toggleAllRowsExpanded = expanded => {
      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
        table.setExpanded(true);
      } else {
        table.setExpanded({});
      }
    };
    table.resetExpanded = defaultState => {
      var _table$initialState$e, _table$initialState;
      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
    };
    table.getCanSomeRowsExpand = () => {
      return table.getPrePaginationRowModel().flatRows.some(row => row.getCanExpand());
    };
    table.getToggleAllRowsExpandedHandler = () => {
      return e => {
        e.persist == null || e.persist();
        table.toggleAllRowsExpanded();
      };
    };
    table.getIsSomeRowsExpanded = () => {
      const expanded = table.getState().expanded;
      return expanded === true || Object.values(expanded).some(Boolean);
    };
    table.getIsAllRowsExpanded = () => {
      const expanded = table.getState().expanded;

      // If expanded is true, save some cycles and return true
      if (typeof expanded === 'boolean') {
        return expanded === true;
      }
      if (!Object.keys(expanded).length) {
        return false;
      }

      // If any row is not expanded, return false
      if (table.getRowModel().flatRows.some(row => !row.getIsExpanded())) {
        return false;
      }

      // They must all be expanded :shrug:
      return true;
    };
    table.getExpandedDepth = () => {
      let maxDepth = 0;
      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
      rowIds.forEach(id => {
        const splitId = id.split('.');
        maxDepth = Math.max(maxDepth, splitId.length);
      });
      return maxDepth;
    };
    table.getPreExpandedRowModel = () => table.getSortedRowModel();
    table.getExpandedRowModel = () => {
      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
        table._getExpandedRowModel = table.options.getExpandedRowModel(table);
      }
      if (table.options.manualExpanding || !table._getExpandedRowModel) {
        return table.getPreExpandedRowModel();
      }
      return table._getExpandedRowModel();
    };
  },
  createRow: (row, table) => {
    row.toggleExpanded = expanded => {
      table.setExpanded(old => {
        var _expanded;
        const exists = old === true ? true : !!(old != null && old[row.id]);
        let oldExpanded = {};
        if (old === true) {
          Object.keys(table.getRowModel().rowsById).forEach(rowId => {
            oldExpanded[rowId] = true;
          });
        } else {
          oldExpanded = old;
        }
        expanded = (_expanded = expanded) != null ? _expanded : !exists;
        if (!exists && expanded) {
          return {
            ...oldExpanded,
            [row.id]: true
          };
        }
        if (exists && !expanded) {
          const {
            [row.id]: _,
            ...rest
          } = oldExpanded;
          return rest;
        }
        return old;
      });
    };
    row.getIsExpanded = () => {
      var _table$options$getIsR;
      const expanded = table.getState().expanded;
      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
    };
    row.getCanExpand = () => {
      var _table$options$getRow, _table$options$enable, _row$subRows;
      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
    row.getIsAllParentsExpanded = () => {
      let isFullyExpanded = true;
      let currentRow = row;
      while (isFullyExpanded && currentRow.parentId) {
        currentRow = table.getRow(currentRow.parentId, true);
        isFullyExpanded = currentRow.getIsExpanded();
      }
      return isFullyExpanded;
    };
    row.getToggleExpandedHandler = () => {
      const canExpand = row.getCanExpand();
      return () => {
        if (!canExpand) return;
        row.toggleExpanded();
      };
    };
  }
};

//

const defaultPageIndex = 0;
const defaultPageSize = 10;
const getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
const RowPagination = {
  getInitialState: state => {
    return {
      ...state,
      pagination: {
        ...getDefaultPaginationState(),
        ...(state == null ? void 0 : state.pagination)
      }
    };
  },
  getDefaultOptions: table => {
    return {
      onPaginationChange: makeStateUpdater('pagination', table)
    };
  },
  createTable: table => {
    let registered = false;
    let queued = false;
    table._autoResetPageIndex = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetPageIndex();
          queued = false;
        });
      }
    };
    table.setPagination = updater => {
      const safeUpdater = old => {
        let newState = functionalUpdate(updater, old);
        return newState;
      };
      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
    };
    table.resetPagination = defaultState => {
      var _table$initialState$p;
      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
    };
    table.setPageIndex = updater => {
      table.setPagination(old => {
        let pageIndex = functionalUpdate(updater, old.pageIndex);
        const maxPageIndex = typeof table.options.pageCount === 'undefined' || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
        return {
          ...old,
          pageIndex
        };
      });
    };
    table.resetPageIndex = defaultState => {
      var _table$initialState$p2, _table$initialState;
      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
    };
    table.resetPageSize = defaultState => {
      var _table$initialState$p3, _table$initialState2;
      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
    };
    table.setPageSize = updater => {
      table.setPagination(old => {
        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
        const topRowIndex = old.pageSize * old.pageIndex;
        const pageIndex = Math.floor(topRowIndex / pageSize);
        return {
          ...old,
          pageIndex,
          pageSize
        };
      });
    };
    //deprecated
    table.setPageCount = updater => table.setPagination(old => {
      var _table$options$pageCo;
      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
      if (typeof newPageCount === 'number') {
        newPageCount = Math.max(-1, newPageCount);
      }
      return {
        ...old,
        pageCount: newPageCount
      };
    });
    table.getPageOptions = memo(() => [table.getPageCount()], pageCount => {
      let pageOptions = [];
      if (pageCount && pageCount > 0) {
        pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);
      }
      return pageOptions;
    }, getMemoOptions(table.options, 'debugTable', 'getPageOptions'));
    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
    table.getCanNextPage = () => {
      const {
        pageIndex
      } = table.getState().pagination;
      const pageCount = table.getPageCount();
      if (pageCount === -1) {
        return true;
      }
      if (pageCount === 0) {
        return false;
      }
      return pageIndex < pageCount - 1;
    };
    table.previousPage = () => {
      return table.setPageIndex(old => old - 1);
    };
    table.nextPage = () => {
      return table.setPageIndex(old => {
        return old + 1;
      });
    };
    table.firstPage = () => {
      return table.setPageIndex(0);
    };
    table.lastPage = () => {
      return table.setPageIndex(table.getPageCount() - 1);
    };
    table.getPrePaginationRowModel = () => table.getExpandedRowModel();
    table.getPaginationRowModel = () => {
      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
        table._getPaginationRowModel = table.options.getPaginationRowModel(table);
      }
      if (table.options.manualPagination || !table._getPaginationRowModel) {
        return table.getPrePaginationRowModel();
      }
      return table._getPaginationRowModel();
    };
    table.getPageCount = () => {
      var _table$options$pageCo2;
      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);
    };
    table.getRowCount = () => {
      var _table$options$rowCou;
      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;
    };
  }
};

//

const getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
});
const RowPinning = {
  getInitialState: state => {
    return {
      rowPinning: getDefaultRowPinningState(),
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onRowPinningChange: makeStateUpdater('rowPinning', table)
    };
  },
  createRow: (row, table) => {
    row.pin = (position, includeLeafRows, includeParentRows) => {
      const leafRowIds = includeLeafRows ? row.getLeafRows().map(_ref => {
        let {
          id
        } = _ref;
        return id;
      }) : [];
      const parentRowIds = includeParentRows ? row.getParentRows().map(_ref2 => {
        let {
          id
        } = _ref2;
        return id;
      }) : [];
      const rowIds = new Set([...parentRowIds, row.id, ...leafRowIds]);
      table.setRowPinning(old => {
        var _old$top3, _old$bottom3;
        if (position === 'bottom') {
          var _old$top, _old$bottom;
          return {
            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter(d => !(rowIds != null && rowIds.has(d))),
            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter(d => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)]
          };
        }
        if (position === 'top') {
          var _old$top2, _old$bottom2;
          return {
            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter(d => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)],
            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter(d => !(rowIds != null && rowIds.has(d)))
          };
        }
        return {
          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter(d => !(rowIds != null && rowIds.has(d))),
          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter(d => !(rowIds != null && rowIds.has(d)))
        };
      });
    };
    row.getCanPin = () => {
      var _ref3;
      const {
        enableRowPinning,
        enablePinning
      } = table.options;
      if (typeof enableRowPinning === 'function') {
        return enableRowPinning(row);
      }
      return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;
    };
    row.getIsPinned = () => {
      const rowIds = [row.id];
      const {
        top,
        bottom
      } = table.getState().rowPinning;
      const isTop = rowIds.some(d => top == null ? void 0 : top.includes(d));
      const isBottom = rowIds.some(d => bottom == null ? void 0 : bottom.includes(d));
      return isTop ? 'top' : isBottom ? 'bottom' : false;
    };
    row.getPinnedIndex = () => {
      var _ref4, _visiblePinnedRowIds$;
      const position = row.getIsPinned();
      if (!position) return -1;
      const visiblePinnedRowIds = (_ref4 = position === 'top' ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map(_ref5 => {
        let {
          id
        } = _ref5;
        return id;
      });
      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
    };
  },
  createTable: table => {
    table.setRowPinning = updater => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
    table.resetRowPinning = defaultState => {
      var _table$initialState$r, _table$initialState;
      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
    };
    table.getIsSomeRowsPinned = position => {
      var _pinningState$positio;
      const pinningState = table.getState().rowPinning;
      if (!position) {
        var _pinningState$top, _pinningState$bottom;
        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table._getPinnedRows = (visibleRows, pinnedRowIds, position) => {
      var _table$options$keepPi;
      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ?
      //get all rows that are pinned even if they would not be otherwise visible
      //account for expanded parent rows, but not pagination or filtering
      (pinnedRowIds != null ? pinnedRowIds : []).map(rowId => {
        const row = table.getRow(rowId, true);
        return row.getIsAllParentsExpanded() ? row : null;
      }) :
      //else get only visible rows that are pinned
      (pinnedRowIds != null ? pinnedRowIds : []).map(rowId => visibleRows.find(row => row.id === rowId));
      return rows.filter(Boolean).map(d => ({
        ...d,
        position
      }));
    };
    table.getTopRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top], (allRows, topPinnedRowIds) => table._getPinnedRows(allRows, topPinnedRowIds, 'top'), getMemoOptions(table.options, 'debugRows', 'getTopRows'));
    table.getBottomRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.bottom], (allRows, bottomPinnedRowIds) => table._getPinnedRows(allRows, bottomPinnedRowIds, 'bottom'), getMemoOptions(table.options, 'debugRows', 'getBottomRows'));
    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {
      const topAndBottom = new Set([...(top != null ? top : []), ...(bottom != null ? bottom : [])]);
      return allRows.filter(d => !topAndBottom.has(d.id));
    }, getMemoOptions(table.options, 'debugRows', 'getCenterRows'));
  }
};

//

const RowSelection = {
  getInitialState: state => {
    return {
      rowSelection: {},
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onRowSelectionChange: makeStateUpdater('rowSelection', table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
      // enableGroupingRowSelection: false,
      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
    };
  },
  createTable: table => {
    table.setRowSelection = updater => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
    table.resetRowSelection = defaultState => {
      var _table$initialState$r;
      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
    };
    table.toggleAllRowsSelected = value => {
      table.setRowSelection(old => {
        value = typeof value !== 'undefined' ? value : !table.getIsAllRowsSelected();
        const rowSelection = {
          ...old
        };
        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;

        // We don't use `mutateRowIsSelected` here for performance reasons.
        // All of the rows are flat already, so it wouldn't be worth it
        if (value) {
          preGroupedFlatRows.forEach(row => {
            if (!row.getCanSelect()) {
              return;
            }
            rowSelection[row.id] = true;
          });
        } else {
          preGroupedFlatRows.forEach(row => {
            delete rowSelection[row.id];
          });
        }
        return rowSelection;
      });
    };
    table.toggleAllPageRowsSelected = value => table.setRowSelection(old => {
      const resolvedValue = typeof value !== 'undefined' ? value : !table.getIsAllPageRowsSelected();
      const rowSelection = {
        ...old
      };
      table.getRowModel().rows.forEach(row => {
        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
      });
      return rowSelection;
    });

    // addRowSelectionRange: rowId => {
    //   const {
    //     rows,
    //     rowsById,
    //     options: { selectGroupingRows, selectSubRows },
    //   } = table

    //   const findSelectedRow = (rows: Row[]) => {
    //     let found
    //     rows.find(d => {
    //       if (d.getIsSelected()) {
    //         found = d
    //         return true
    //       }
    //       const subFound = findSelectedRow(d.subRows || [])
    //       if (subFound) {
    //         found = subFound
    //         return true
    //       }
    //       return false
    //     })
    //     return found
    //   }

    //   const firstRow = findSelectedRow(rows) || rows[0]
    //   const lastRow = rowsById[rowId]

    //   let include = false
    //   const selectedRowIds = {}

    //   const addRow = (row: Row) => {
    //     mutateRowIsSelected(selectedRowIds, row.id, true, {
    //       rowsById,
    //       selectGroupingRows: selectGroupingRows!,
    //       selectSubRows: selectSubRows!,
    //     })
    //   }

    //   table.rows.forEach(row => {
    //     const isFirstRow = row.id === firstRow.id
    //     const isLastRow = row.id === lastRow.id

    //     if (isFirstRow || isLastRow) {
    //       if (!include) {
    //         include = true
    //       } else if (include) {
    //         addRow(row)
    //         include = false
    //       }
    //     }

    //     if (include) {
    //       addRow(row)
    //     }
    //   })

    //   table.setRowSelection(selectedRowIds)
    // },
    table.getPreSelectedRowModel = () => table.getCoreRowModel();
    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, 'debugTable', 'getSelectedRowModel'));
    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, 'debugTable', 'getFilteredSelectedRowModel'));
    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, 'debugTable', 'getGroupedSelectedRowModel'));

    ///

    // getGroupingRowCanSelect: rowId => {
    //   const row = table.getRow(rowId)

    //   if (!row) {
    //     throw new Error()
    //   }

    //   if (typeof table.options.enableGroupingRowSelection === 'function') {
    //     return table.options.enableGroupingRowSelection(row)
    //   }

    //   return table.options.enableGroupingRowSelection ?? false
    // },

    table.getIsAllRowsSelected = () => {
      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
      const {
        rowSelection
      } = table.getState();
      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
      if (isAllRowsSelected) {
        if (preGroupedFlatRows.some(row => row.getCanSelect() && !rowSelection[row.id])) {
          isAllRowsSelected = false;
        }
      }
      return isAllRowsSelected;
    };
    table.getIsAllPageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter(row => row.getCanSelect());
      const {
        rowSelection
      } = table.getState();
      let isAllPageRowsSelected = !!paginationFlatRows.length;
      if (isAllPageRowsSelected && paginationFlatRows.some(row => !rowSelection[row.id])) {
        isAllPageRowsSelected = false;
      }
      return isAllPageRowsSelected;
    };
    table.getIsSomeRowsSelected = () => {
      var _table$getState$rowSe;
      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
    };
    table.getIsSomePageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows;
      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter(row => row.getCanSelect()).some(d => d.getIsSelected() || d.getIsSomeSelected());
    };
    table.getToggleAllRowsSelectedHandler = () => {
      return e => {
        table.toggleAllRowsSelected(e.target.checked);
      };
    };
    table.getToggleAllPageRowsSelectedHandler = () => {
      return e => {
        table.toggleAllPageRowsSelected(e.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row.toggleSelected = (value, opts) => {
      const isSelected = row.getIsSelected();
      table.setRowSelection(old => {
        var _opts$selectChildren;
        value = typeof value !== 'undefined' ? value : !isSelected;
        if (row.getCanSelect() && isSelected === value) {
          return old;
        }
        const selectedRowIds = {
          ...old
        };
        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);
        return selectedRowIds;
      });
    };
    row.getIsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isRowSelected(row, rowSelection);
    };
    row.getIsSomeSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === 'some';
    };
    row.getIsAllSubRowsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === 'all';
    };
    row.getCanSelect = () => {
      var _table$options$enable;
      if (typeof table.options.enableRowSelection === 'function') {
        return table.options.enableRowSelection(row);
      }
      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
    };
    row.getCanSelectSubRows = () => {
      var _table$options$enable2;
      if (typeof table.options.enableSubRowSelection === 'function') {
        return table.options.enableSubRowSelection(row);
      }
      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
    };
    row.getCanMultiSelect = () => {
      var _table$options$enable3;
      if (typeof table.options.enableMultiRowSelection === 'function') {
        return table.options.enableMultiRowSelection(row);
      }
      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
    };
    row.getToggleSelectedHandler = () => {
      const canSelect = row.getCanSelect();
      return e => {
        var _target;
        if (!canSelect) return;
        row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
const mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {
  var _row$subRows;
  const row = table.getRow(id, true);

  // const isGrouped = row.getIsGrouped()

  // if ( // TODO: enforce grouping row selection rules
  //   !isGrouped ||
  //   (isGrouped && table.options.enableGroupingRowSelection)
  // ) {
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach(key => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id] = true;
    }
  } else {
    delete selectedRowIds[id];
  }
  // }

  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach(row => mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};

  // Filters top level and nested rows
  const recurseRows = function (rows, depth) {
    return rows.map(row => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach(subRow => {
    // Bail out early if we know both of these
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }

    // Check row selection of nested subrows
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === 'all') {
        someSelected = true;
      } else if (subRowChildrenSelected === 'some') {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? 'all' : someSelected ? 'some' : false;
}

const reSplitAlphaNumeric = /([0-9]+)/gm;
const alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
const alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};

// The text filter is more basic (less numeric support)
// but is much faster
const text = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};

// The text filter is more basic (less numeric support)
// but is much faster
const textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
const datetime = (rowA, rowB, columnId) => {
  const a = rowA.getValue(columnId);
  const b = rowB.getValue(columnId);

  // Can handle nullish values
  // Use > and < because == (and ===) doesn't work with
  // Date objects (would require calling getTime()).
  return a > b ? 1 : a < b ? -1 : 0;
};
const basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};

// Utils

function compareBasic(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function toString(a) {
  if (typeof a === 'number') {
    if (isNaN(a) || a === Infinity || a === -Infinity) {
      return '';
    }
    return String(a);
  }
  if (typeof a === 'string') {
    return a;
  }
  return '';
}

// Mixed sorting is slow, but very inclusive of many edge cases.
// It handles numbers, mixed alphanumeric combinations, and even
// null, undefined, and Infinity
function compareAlphanumeric(aStr, bStr) {
  // Split on number groups, but keep the delimiter
  // Then remove falsey split values
  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);

  // While
  while (a.length && b.length) {
    const aa = a.shift();
    const bb = b.shift();
    const an = parseInt(aa, 10);
    const bn = parseInt(bb, 10);
    const combo = [an, bn].sort();

    // Both are string
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }

    // One is a string, one is a number
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }

    // Both are numbers
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a.length - b.length;
}

// Exports

const sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};

//

const RowSorting = {
  getInitialState: state => {
    return {
      sorting: [],
      ...state
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: 'auto',
      sortUndefined: 1
    };
  },
  getDefaultOptions: table => {
    return {
      onSortingChange: makeStateUpdater('sorting', table),
      isMultiSortEvent: e => {
        return e.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoSortingFn = () => {
      const firstRows = table.getFilteredRowModel().flatRows.slice(10);
      let isString = false;
      for (const row of firstRows) {
        const value = row == null ? void 0 : row.getValue(column.id);
        if (Object.prototype.toString.call(value) === '[object Date]') {
          return sortingFns.datetime;
        }
        if (typeof value === 'string') {
          isString = true;
          if (value.split(reSplitAlphaNumeric).length > 1) {
            return sortingFns.alphanumeric;
          }
        }
      }
      if (isString) {
        return sortingFns.text;
      }
      return sortingFns.basic;
    };
    column.getAutoSortDir = () => {
      const firstRow = table.getFilteredRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === 'string') {
        return 'asc';
      }
      return 'desc';
    };
    column.getSortingFn = () => {
      var _table$options$sortin, _table$options$sortin2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === 'auto' ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
    };
    column.toggleSorting = (desc, multi) => {
      // if (column.columns.length) {
      //   column.columns.forEach((c, i) => {
      //     if (c.id) {
      //       table.toggleColumnSorting(c.id, undefined, multi || !!i)
      //     }
      //   })
      //   return
      // }

      // this needs to be outside of table.setSorting to be in sync with rerender
      const nextSortingOrder = column.getNextSortingOrder();
      const hasManualValue = typeof desc !== 'undefined' && desc !== null;
      table.setSorting(old => {
        // Find any existing sorting for this column
        const existingSorting = old == null ? void 0 : old.find(d => d.id === column.id);
        const existingIndex = old == null ? void 0 : old.findIndex(d => d.id === column.id);
        let newSorting = [];

        // What should we do with this sort action?
        let sortAction;
        let nextDesc = hasManualValue ? desc : nextSortingOrder === 'desc';

        // Multi-mode
        if (old != null && old.length && column.getCanMultiSort() && multi) {
          if (existingSorting) {
            sortAction = 'toggle';
          } else {
            sortAction = 'add';
          }
        } else {
          // Normal mode
          if (old != null && old.length && existingIndex !== old.length - 1) {
            sortAction = 'replace';
          } else if (existingSorting) {
            sortAction = 'toggle';
          } else {
            sortAction = 'replace';
          }
        }

        // Handle toggle states that will remove the sorting
        if (sortAction === 'toggle') {
          // If we are "actually" toggling (not a manual set value), should we remove the sorting?
          if (!hasManualValue) {
            // Is our intention to remove?
            if (!nextSortingOrder) {
              sortAction = 'remove';
            }
          }
        }
        if (sortAction === 'add') {
          var _table$options$maxMul;
          newSorting = [...old, {
            id: column.id,
            desc: nextDesc
          }];
          // Take latest n columns
          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
        } else if (sortAction === 'toggle') {
          // This flips (or sets) the
          newSorting = old.map(d => {
            if (d.id === column.id) {
              return {
                ...d,
                desc: nextDesc
              };
            }
            return d;
          });
        } else if (sortAction === 'remove') {
          newSorting = old.filter(d => d.id !== column.id);
        } else {
          newSorting = [{
            id: column.id,
            desc: nextDesc
          }];
        }
        return newSorting;
      });
    };
    column.getFirstSortDir = () => {
      var _ref, _column$columnDef$sor;
      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === 'desc';
      return sortDescFirst ? 'desc' : 'asc';
    };
    column.getNextSortingOrder = multi => {
      var _table$options$enable, _table$options$enable2;
      const firstSortDirection = column.getFirstSortDir();
      const isSorted = column.getIsSorted();
      if (!isSorted) {
        return firstSortDirection;
      }
      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && (
      // If enableSortRemove, enable in general
      multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true) // If multi, don't allow if enableMultiRemove))
      ) {
        return false;
      }
      return isSorted === 'desc' ? 'asc' : 'desc';
    };
    column.getCanSort = () => {
      var _column$columnDef$ena, _table$options$enable3;
      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
    };
    column.getCanMultiSort = () => {
      var _ref2, _column$columnDef$ena2;
      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
    };
    column.getIsSorted = () => {
      var _table$getState$sorti;
      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find(d => d.id === column.id);
      return !columnSort ? false : columnSort.desc ? 'desc' : 'asc';
    };
    column.getSortIndex = () => {
      var _table$getState$sorti2, _table$getState$sorti3;
      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex(d => d.id === column.id)) != null ? _table$getState$sorti2 : -1;
    };
    column.clearSorting = () => {
      //clear sorting for just 1 column
      table.setSorting(old => old != null && old.length ? old.filter(d => d.id !== column.id) : []);
    };
    column.getToggleSortingHandler = () => {
      const canSort = column.getCanSort();
      return e => {
        if (!canSort) return;
        e.persist == null || e.persist();
        column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);
      };
    };
  },
  createTable: table => {
    table.setSorting = updater => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
    table.resetSorting = defaultState => {
      var _table$initialState$s, _table$initialState;
      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
    };
    table.getPreSortedRowModel = () => table.getGroupedRowModel();
    table.getSortedRowModel = () => {
      if (!table._getSortedRowModel && table.options.getSortedRowModel) {
        table._getSortedRowModel = table.options.getSortedRowModel(table);
      }
      if (table.options.manualSorting || !table._getSortedRowModel) {
        return table.getPreSortedRowModel();
      }
      return table._getSortedRowModel();
    };
  }
};

const builtInFeatures = [Headers, ColumnVisibility, ColumnOrdering, ColumnPinning, ColumnFaceting, ColumnFiltering, GlobalFaceting,
//depends on ColumnFaceting
GlobalFiltering,
//depends on ColumnFiltering
RowSorting, ColumnGrouping,
//depends on RowSorting
RowExpanding, RowPagination, RowPinning, RowSelection, ColumnSizing];

//

function createTable(options) {
  var _options$_features, _options$initialState;
  if (process.env.NODE_ENV !== 'production' && (options.debugAll || options.debugTable)) {
    console.info('Creating Table Instance...');
  }
  const _features = [...builtInFeatures, ...((_options$_features = options._features) != null ? _options$_features : [])];
  let table = {
    _features
  };
  const defaultOptions = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = options => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions, options);
    }
    return {
      ...defaultOptions,
      ...options
    };
  };
  const coreInitialState = {};
  let initialState = {
    ...coreInitialState,
    ...((_options$initialState = options.initialState) != null ? _options$initialState : {})
  };
  table._features.forEach(feature => {
    var _feature$getInitialSt;
    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features,
    options: {
      ...defaultOptions,
      ...options
    },
    initialState,
    _queue: cb => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;

        // Schedule a microtask to run the queued callbacks after
        // the current call stack (render, etc) has finished.
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch(error => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: updater => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: updater => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index, parent) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index].join('.') : index}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up

    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (id, searchAll) => {
      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];
      if (!row) {
        row = table.getCoreRowModel().rowsById[id];
        if (!row) {
          if (process.env.NODE_ENV !== 'production') {
            throw new Error(`getRow could not find row with ID: ${id}`);
          }
          throw new Error();
        }
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], defaultColumn => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: props => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: props => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, getMemoOptions(options, 'debugColumns', '_getDefaultColumnDef')),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], columnDefs => {
      const recurseColumns = function (columnDefs, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs.map(columnDef => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, getMemoOptions(options, 'debugColumns', 'getAllColumns')),
    getAllFlatColumns: memo(() => [table.getAllColumns()], allColumns => {
      return allColumns.flatMap(column => {
        return column.getFlatColumns();
      });
    }, getMemoOptions(options, 'debugColumns', 'getAllFlatColumns')),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], flatColumns => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, getMemoOptions(options, 'debugColumns', 'getAllFlatColumnsById')),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns) => {
      let leafColumns = allColumns.flatMap(column => column.getLeafColumns());
      return orderColumns(leafColumns);
    }, getMemoOptions(options, 'debugColumns', 'getAllLeafColumns')),
    getColumn: columnId => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (process.env.NODE_ENV !== 'production' && !column) {
        console.error(`[Table] Column with id '${columnId}' does not exist.`);
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  for (let index = 0; index < table._features.length; index++) {
    const feature = table._features[index];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}

function getCoreRowModel() {
  return table => memo(() => [table.options.data], data => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function (originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i = 0; i < originalRows.length; i++) {
        // This could be an expensive check at scale, so we should move it somewhere else, but where?
        // if (!id) {
        //   if (process.env.NODE_ENV !== 'production') {
        //     throw new Error(`getRowId expected an ID, but got ${id}`)
        //   }
        // }

        // Make the row
        const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);

        // Keep track of every row in a flat array
        rowModel.flatRows.push(row);
        // Also keep track of every row by its ID
        rowModel.rowsById[row.id] = row;
        // Push table row into parent
        rows.push(row);

        // Get the original subrows
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i], i);

          // Then recursively access them
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, getMemoOptions(table.options, 'debugTable', 'getRowModel', () => table._autoResetPageIndex()));
}

function getExpandedRowModel() {
  return table => memo(() => [table.getState().expanded, table.getPreExpandedRowModel(), table.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {
    if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {
      return rowModel;
    }
    if (!paginateExpandedRows) {
      // Only expand rows at this point if they are being paginated
      return rowModel;
    }
    return expandRows(rowModel);
  }, getMemoOptions(table.options, 'debugTable', 'getExpandedRowModel'));
}
function expandRows(rowModel) {
  const expandedRows = [];
  const handleRow = row => {
    var _row$subRows;
    expandedRows.push(row);
    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {
      row.subRows.forEach(handleRow);
    }
  };
  rowModel.rows.forEach(handleRow);
  return {
    rows: expandedRows,
    flatRows: rowModel.flatRows,
    rowsById: rowModel.rowsById
  };
}

function getGroupedRowModel() {
  return table => memo(() => [table.getState().grouping, table.getPreGroupedRowModel()], (grouping, rowModel) => {
    if (!rowModel.rows.length || !grouping.length) {
      rowModel.rows.forEach(row => {
        row.depth = 0;
        row.parentId = undefined;
      });
      return rowModel;
    }

    // Filter the grouping list down to columns that exist
    const existingGrouping = grouping.filter(columnId => table.getColumn(columnId));
    const groupedFlatRows = [];
    const groupedRowsById = {};
    // const onlyGroupedFlatRows: Row[] = [];
    // const onlyGroupedRowsById: Record<RowId, Row> = {};
    // const nonGroupedFlatRows: Row[] = [];
    // const nonGroupedRowsById: Record<RowId, Row> = {};

    // Recursively group the data
    const groupUpRecursively = function (rows, depth, parentId) {
      if (depth === void 0) {
        depth = 0;
      }
      // Grouping depth has been been met
      // Stop grouping and simply rewrite thd depth and row relationships
      if (depth >= existingGrouping.length) {
        return rows.map(row => {
          row.depth = depth;
          groupedFlatRows.push(row);
          groupedRowsById[row.id] = row;
          if (row.subRows) {
            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);
          }
          return row;
        });
      }
      const columnId = existingGrouping[depth];

      // Group the rows together for this level
      const rowGroupsMap = groupBy(rows, columnId);

      // Perform aggregations for each group
      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {
        let [groupingValue, groupedRows] = _ref;
        let id = `${columnId}:${groupingValue}`;
        id = parentId ? `${parentId}>${id}` : id;

        // First, Recurse to group sub rows before aggregation
        const subRows = groupUpRecursively(groupedRows, depth + 1, id);
        subRows.forEach(subRow => {
          subRow.parentId = id;
        });

        // Flatten the leaf rows of the rows in this group
        const leafRows = depth ? flattenBy(groupedRows, row => row.subRows) : groupedRows;
        const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);
        Object.assign(row, {
          groupingColumnId: columnId,
          groupingValue,
          subRows,
          leafRows,
          getValue: columnId => {
            // Don't aggregate columns that are in the grouping
            if (existingGrouping.includes(columnId)) {
              if (row._valuesCache.hasOwnProperty(columnId)) {
                return row._valuesCache[columnId];
              }
              if (groupedRows[0]) {
                var _groupedRows$0$getVal;
                row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;
              }
              return row._valuesCache[columnId];
            }
            if (row._groupingValuesCache.hasOwnProperty(columnId)) {
              return row._groupingValuesCache[columnId];
            }

            // Aggregate the values
            const column = table.getColumn(columnId);
            const aggregateFn = column == null ? void 0 : column.getAggregationFn();
            if (aggregateFn) {
              row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);
              return row._groupingValuesCache[columnId];
            }
          }
        });
        subRows.forEach(subRow => {
          groupedFlatRows.push(subRow);
          groupedRowsById[subRow.id] = subRow;
          // if (subRow.getIsGrouped?.()) {
          //   onlyGroupedFlatRows.push(subRow);
          //   onlyGroupedRowsById[subRow.id] = subRow;
          // } else {
          //   nonGroupedFlatRows.push(subRow);
          //   nonGroupedRowsById[subRow.id] = subRow;
          // }
        });
        return row;
      });
      return aggregatedGroupedRows;
    };
    const groupedRows = groupUpRecursively(rowModel.rows, 0);
    groupedRows.forEach(subRow => {
      groupedFlatRows.push(subRow);
      groupedRowsById[subRow.id] = subRow;
      // if (subRow.getIsGrouped?.()) {
      //   onlyGroupedFlatRows.push(subRow);
      //   onlyGroupedRowsById[subRow.id] = subRow;
      // } else {
      //   nonGroupedFlatRows.push(subRow);
      //   nonGroupedRowsById[subRow.id] = subRow;
      // }
    });
    return {
      rows: groupedRows,
      flatRows: groupedFlatRows,
      rowsById: groupedRowsById
    };
  }, getMemoOptions(table.options, 'debugTable', 'getGroupedRowModel', () => {
    table._queue(() => {
      table._autoResetExpanded();
      table._autoResetPageIndex();
    });
  }));
}
function groupBy(rows, columnId) {
  const groupMap = new Map();
  return rows.reduce((map, row) => {
    const resKey = `${row.getGroupingValue(columnId)}`;
    const previous = map.get(resKey);
    if (!previous) {
      map.set(resKey, [row]);
    } else {
      previous.push(row);
    }
    return map;
  }, groupMap);
}

function getSortedRowModel() {
  return table => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {
    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {
      return rowModel;
    }
    const sortingState = table.getState().sorting;
    const sortedFlatRows = [];

    // Filter out sortings that correspond to non existing columns
    const availableSorting = sortingState.filter(sort => {
      var _table$getColumn;
      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();
    });
    const columnInfoById = {};
    availableSorting.forEach(sortEntry => {
      const column = table.getColumn(sortEntry.id);
      if (!column) return;
      columnInfoById[sortEntry.id] = {
        sortUndefined: column.columnDef.sortUndefined,
        invertSorting: column.columnDef.invertSorting,
        sortingFn: column.getSortingFn()
      };
    });
    const sortData = rows => {
      // This will also perform a stable sorting using the row index
      // if needed.
      const sortedData = rows.map(row => ({
        ...row
      }));
      sortedData.sort((rowA, rowB) => {
        for (let i = 0; i < availableSorting.length; i += 1) {
          var _sortEntry$desc;
          const sortEntry = availableSorting[i];
          const columnInfo = columnInfoById[sortEntry.id];
          const sortUndefined = columnInfo.sortUndefined;
          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;
          let sortInt = 0;

          // All sorting ints should always return in ascending order
          if (sortUndefined) {
            const aValue = rowA.getValue(sortEntry.id);
            const bValue = rowB.getValue(sortEntry.id);
            const aUndefined = aValue === undefined;
            const bUndefined = bValue === undefined;
            if (aUndefined || bUndefined) {
              if (sortUndefined === 'first') return aUndefined ? -1 : 1;
              if (sortUndefined === 'last') return aUndefined ? 1 : -1;
              sortInt = aUndefined && bUndefined ? 0 : aUndefined ? sortUndefined : -sortUndefined;
            }
          }
          if (sortInt === 0) {
            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);
          }

          // If sorting is non-zero, take care of desc and inversion
          if (sortInt !== 0) {
            if (isDesc) {
              sortInt *= -1;
            }
            if (columnInfo.invertSorting) {
              sortInt *= -1;
            }
            return sortInt;
          }
        }
        return rowA.index - rowB.index;
      });

      // If there are sub-rows, sort them
      sortedData.forEach(row => {
        var _row$subRows;
        sortedFlatRows.push(row);
        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
          row.subRows = sortData(row.subRows);
        }
      });
      return sortedData;
    };
    return {
      rows: sortData(rowModel.rows),
      flatRows: sortedFlatRows,
      rowsById: rowModel.rowsById
    };
  }, getMemoOptions(table.options, 'debugTable', 'getSortedRowModel', () => table._autoResetPageIndex()));
}

/**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */

//

/**
 * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.
 */
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/React.createElement(Comp, props) : Comp;
}
function isReactComponent(component) {
  return isClassComponent(component) || typeof component === 'function' || isExoticComponent(component);
}
function isClassComponent(component) {
  return typeof component === 'function' && (() => {
    const proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component) {
  return typeof component === 'object' && typeof component.$$typeof === 'symbol' && ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description);
}
function useReactTable(options) {
  // Compose in the generic options to the user options
  const resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {},
    // noop
    renderFallbackValue: null,
    ...options
  };

  // Create a new table and store it in state
  const [tableRef] = React.useState(() => ({
    current: createTable(resolvedOptions)
  }));

  // By default, manage table state here using the table's initial state
  const [state, setState] = React.useState(() => tableRef.current.initialState);

  // Compose the default state above with any user state. This will allow the user
  // to only control a subset of the state if desired.
  tableRef.current.setOptions(prev => ({
    ...prev,
    ...options,
    state: {
      ...state,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: updater => {
      setState(updater);
      options.onStateChange == null || options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}

const styles$c = {
	"table-base": "_table-base_wtnhx_2"
};

const SimpleTableBase = ({
  children,
  className,
  ...rest
}) => {
  const tableBaseClassNames = cx(className, styles$c["table-base"]);
  return /* @__PURE__ */ jsx(
    "table",
    {
      "data-anv": "simple-table-base",
      ...rest,
      className: tableBaseClassNames,
      children
    }
  );
};
const DataTableBase = ({
  children,
  className,
  colCount,
  rowCount,
  hasSubRows,
  ...rest
}) => {
  const tableBaseClassNames = cx(className, styles$c["table-base"]);
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-anv": "data-table-base",
      ...rest,
      className: tableBaseClassNames,
      "aria-colcount": colCount,
      "aria-rowcount": rowCount,
      role: hasSubRows ? "treegrid" : "grid",
      children
    }
  );
};
const TableBase = ({ type, ...rest }) => {
  if (type === "simple") {
    return /* @__PURE__ */ jsx(SimpleTableBase, { ...rest });
  }
  if ("rowCount" in rest && "colCount" in rest) {
    return /* @__PURE__ */ jsx(
      DataTableBase,
      {
        ...rest,
        rowCount: rest.rowCount,
        colCount: rest.colCount
      }
    );
  }
};

const getCommonPinningStyles = (column) => {
  const isPinned = column.getIsPinned();
  return {
    left: isPinned === "left" ? `${column.getStart("left")}px` : void 0,
    right: isPinned === "right" ? `${column.getAfter("right")}px` : void 0,
    position: isPinned ? "sticky" : "relative",
    width: `calc(var(--a2-table-col-${column.getIndex()}-size) * 1px)`,
    zIndex: isPinned ? 1 : 0
  };
};

const getCommonPinningClasses = (column) => {
  const isPinned = column.getIsPinned();
  const isLastLeftPinnedColumn = isPinned === "left" && column.getIsLastColumn("left");
  const isFirstRightPinnedColumn = isPinned === "right" && column.getIsFirstColumn("right");
  if (isLastLeftPinnedColumn) {
    return styles$e["last-pinned-left-column"];
  }
  if (isFirstRightPinnedColumn) {
    return styles$e["first-pinned-right-column"];
  }
};

const styles$b = {
	"table-body": "_table-body_zs2gj_2"
};

function TableBody({ type, children, ...rest }) {
  const classes = cx(styles$b["table-body"], rest.className);
  const Element = type === "simple" ? "tbody" : "div";
  return /* @__PURE__ */ jsx(
    Element,
    {
      ...rest,
      className: classes,
      role: type === "simple" ? void 0 : "rowgroup",
      children
    }
  );
}

const DataTableContext = createContext(
  void 0
);

function useDataTableContext() {
  const context = useContext(DataTableContext);
  if (context === void 0) {
    throw new Error(
      "useDataTableContext must be used within a DataTableContextProvider"
    );
  }
  return context;
}

const TableBodyCell = forwardRef(({ type, children, className, isExpandCell, isSelectCell, ...rest }, ref) => {
  const classes = cx(styles$e["table-body-cell"], className, {
    [styles$e["table-cell-internal-expand"]]: isExpandCell,
    [styles$e["table-cell-internal-select"]]: isSelectCell
  });
  const CellElement = type === "simple" ? "td" : "div";
  return /* @__PURE__ */ jsx(
    CellElement,
    {
      ref,
      "data-anv": "table-body-cell",
      ...rest,
      className: classes,
      role: type === "simple" ? void 0 : "gridcell",
      children
    }
  );
});
TableBodyCell.displayName = "TableBodyCell";

const SvgEdit = (props) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M3 17.46v3.04c0 .28.22.5.5.5h3.04c.13 0 .26-.05.35-.15L17.81 9.94l-3.75-3.75L3.15 17.1c-.1.1-.15.22-.15.36zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" }));

const styles$a = {
	"data-table-body-cell-input": "_data-table-body-cell-input_b0det_2",
	"data-table-body-cell-select-trigger": "_data-table-body-cell-select-trigger_b0det_3",
	"data-table-body-select-cell": "_data-table-body-select-cell_b0det_34",
	"data-table-body-cell-editable": "_data-table-body-cell-editable_b0det_52",
	"data-table-body-cell-edit-icon": "_data-table-body-cell-edit-icon_b0det_52"
};

const DataTableEditableCellEditIcon = () => {
  return /* @__PURE__ */ jsx(
    Icon,
    {
      svg: SvgEdit,
      size: "small",
      color: "subtle",
      className: styles$a["data-table-body-cell-edit-icon"],
      "aria-label": "Edit cell value"
    }
  );
};

const useEditCell = ({
  initialValue,
  onChange,
  cellPosition,
  rowId
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(initialValue);
  const editValueRef = useRef(initialValue);
  const {
    focusCell,
    isTableFocused,
    initializeFocus,
    setIsOffGridInteractionOccurring
  } = useDataTableContext();
  const handleEditStateChange = useCallback(
    (isEditing2) => {
      setIsEditing(isEditing2);
      setIsOffGridInteractionOccurring(isEditing2);
    },
    [setIsOffGridInteractionOccurring]
  );
  const updateEditValue = useCallback((value) => {
    editValueRef.current = value;
    setEditValue(value);
  }, []);
  const handleFocusCell = useCallback(() => {
    if (!isTableFocused) {
      initializeFocus();
      setTimeout(() => {
        focusCell(cellPosition);
      });
    } else {
      setTimeout(() => {
        focusCell(cellPosition);
      });
    }
  }, [cellPosition, focusCell, isTableFocused, initializeFocus]);
  const handleSave = useCallback(
    (value) => {
      onChange(value, rowId);
      handleEditStateChange(false);
      handleFocusCell();
    },
    [onChange, rowId, handleFocusCell, handleEditStateChange]
  );
  const saveValue = useCallback(() => {
    handleSave(editValueRef.current);
  }, [handleSave]);
  const cancelEdit = useCallback(() => {
    setEditValue(initialValue);
    handleEditStateChange(false);
    handleFocusCell();
  }, [initialValue, handleFocusCell, handleEditStateChange]);
  const handleClick = useCallback(() => {
    if (isEditing) return;
    handleEditStateChange(true);
  }, [isEditing, handleEditStateChange]);
  const handleKeyDown = useCallback(
    (event) => {
      if (event.key === "Enter" || event.key === "F2") {
        if (isEditing) {
          saveValue();
        } else {
          handleEditStateChange(true);
        }
      }
      if (event.key === "Escape") {
        cancelEdit();
      }
    },
    [isEditing, saveValue, cancelEdit, handleEditStateChange]
  );
  const handleBlur = useCallback(() => {
    saveValue();
  }, [saveValue]);
  const returnValue = useMemo(
    () => ({
      isEditing,
      editValue,
      updateEditValue,
      saveValue,
      cancelEdit,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      onBlur: handleBlur
    }),
    [
      isEditing,
      editValue,
      updateEditValue,
      saveValue,
      cancelEdit,
      handleClick,
      handleKeyDown,
      handleBlur
    ]
  );
  return returnValue;
};

const styles$9 = {
	"data-table-body-cell": "_data-table-body-cell_1ub1i_2",
	"data-table-body-cell-editing": "_data-table-body-cell-editing_1ub1i_32",
	"data-table-header-cell": "_data-table-header-cell_1ub1i_33",
	"data-table-footer-cell": "_data-table-footer-cell_1ub1i_36",
	"data-table-body-cell-hovered": "_data-table-body-cell-hovered_1ub1i_81"
};

const DataTableEditableTextCell = ({
  cellProps,
  children,
  rowId,
  onChange,
  cellPosition,
  value
}) => {
  const { isEditing, editValue, updateEditValue, onClick, onKeyDown, onBlur } = useEditCell({
    initialValue: value,
    onChange,
    cellPosition,
    rowId
  });
  const inputRef = useRef(null);
  const { className, ...restCellProps } = cellProps;
  const handleChange = useCallback(
    (e) => {
      updateEditValue(e.target.value);
    },
    [updateEditValue]
  );
  useEffect(() => {
    if (isEditing) {
      inputRef.current?.focus();
    }
  }, [isEditing]);
  const classes = cx(className, styles$a["data-table-body-cell-editable"], {
    [styles$9["data-table-body-cell-editing"]]: isEditing
  });
  return /* @__PURE__ */ jsxs(
    TableBodyCell,
    {
      ...restCellProps,
      className: classes,
      onClick,
      onKeyDown,
      children: [
        isEditing ? /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(
          "input",
          {
            type: "text",
            className: styles$a["data-table-body-cell-input"],
            ref: inputRef,
            value: editValue,
            onChange: handleChange,
            onBlur
          }
        ) }) : /* @__PURE__ */ jsxs(Fragment, { children: [
          children,
          !isEditing && /* @__PURE__ */ jsx(DataTableEditableCellEditIcon, {})
        ] }),
        /* @__PURE__ */ jsx(SrOnly, { children: isEditing ? "Press F2 to save cell value." : "Press Enter or F2 to edit cell value. Press Escape to cancel." })
      ]
    }
  );
};

const DataTableEditableSelectCell = ({
  cellProps,
  children,
  rowId,
  onChange,
  cellPosition,
  value,
  options
}) => {
  const {
    isEditing,
    onClick,
    onKeyDown,
    saveValue,
    updateEditValue,
    cancelEdit
  } = useEditCell({
    initialValue: value,
    onChange,
    cellPosition,
    rowId
  });
  const { className, ...restCellProps } = cellProps;
  const cellClasses = cx(
    styles$a["data-table-body-cell-editable"],
    styles$a["data-table-body-select-cell"],
    className,
    { [styles$9["data-table-body-cell-editing"]]: isEditing }
  );
  const handleKeyDown = (e, triggerFn) => {
    if (e.key === "ArrowDown" && !isEditing) {
      onKeyDown?.(e);
      return;
    }
    onKeyDown?.(e);
    triggerFn?.(e);
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Menu,
      {
        open: isEditing,
        onOutsidePress: saveValue,
        trigger: ({
          ref: triggerRef,
          onKeyDown: triggerOnKeyDown,
          ...rest
        }) => {
          return /* @__PURE__ */ jsxs(
            TableBodyCell,
            {
              ...restCellProps,
              className: cellClasses,
              onClick,
              children: [
                /* @__PURE__ */ jsx(
                  "button",
                  {
                    ...rest,
                    ref: triggerRef,
                    className: styles$a["data-table-body-cell-select-trigger"],
                    onKeyDown: (e) => handleKeyDown(e, () => triggerOnKeyDown?.(e)),
                    children
                  }
                ),
                !isEditing && /* @__PURE__ */ jsx(DataTableEditableCellEditIcon, {})
              ]
            }
          );
        },
        children: isEditing && options.map((item) => {
          return /* @__PURE__ */ jsx(
            Menu.Item,
            {
              label: item.label,
              onClick: () => {
                updateEditValue(item.value);
                saveValue();
              },
              onKeyDown: (e) => {
                if (e.key === "Escape" || e.key === "F2") {
                  cancelEdit();
                }
              }
            },
            item.value
          );
        })
      }
    ),
    /* @__PURE__ */ jsx(SrOnly, { children: isEditing ? "Press Enter or Space to select a cell value. Press Escape or F2 to cancel." : "Press Enter or F2 to edit cell value." })
  ] });
};

const DataTableEditableMultiselectCell = ({
  cellProps,
  children,
  rowId,
  onChange,
  cellPosition,
  value,
  options
}) => {
  const {
    isEditing,
    onClick,
    onKeyDown,
    saveValue,
    cancelEdit,
    editValue,
    updateEditValue
  } = useEditCell({
    initialValue: value,
    onChange,
    cellPosition,
    rowId
  });
  const searchFieldRef = useRef(null);
  const [searchValue, setSearchValue] = useState("");
  const listViewRef = useRef(null);
  const { className, ...restCellProps } = cellProps;
  const cellClasses = cx(styles$a["data-table-body-select-cell"], className, {
    [styles$9["data-table-body-cell-editing"]]: isEditing
  });
  const selectedValues = options.filter(
    (item) => editValue.includes(item.value)
  );
  const handleTriggerKeyDown = (e, triggerFn) => {
    onKeyDown?.(e);
    triggerFn?.(e);
  };
  const handleListViewKeyDown = useCallback(
    (e) => {
      if (e.key === "Tab" && !e.shiftKey || e.key === "F2") {
        e.preventDefault();
        e.stopPropagation();
        saveValue();
      }
      if (e.key === "Escape") {
        e.preventDefault();
        e.stopPropagation();
        cancelEdit();
        setSearchValue("");
      }
      if (e.key === "ArrowDown" || e.key === "ArrowUp") {
        e.preventDefault();
      }
    },
    [saveValue, cancelEdit]
  );
  const handleSearchFieldKeyDown = useCallback(
    (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        e.stopPropagation();
        cancelEdit();
        setSearchValue("");
      }
      if (e.key === "ArrowDown") {
        e.preventDefault();
        e.stopPropagation();
        listViewRef.current?.focus();
      }
    },
    [cancelEdit]
  );
  const handleListViewSelectionChange = useCallback(
    (value2) => {
      if (isEditing) {
        updateEditValue(
          value2.map((item) => item.value)
        );
      }
    },
    [updateEditValue, isEditing]
  );
  const filteredItems = useMemo(() => {
    if (searchValue === "") return options;
    return options.filter(
      (item) => item.label.toLowerCase().includes(searchValue.toLowerCase())
    );
  }, [options, searchValue]);
  const handleOnClickOutside = useCallback(() => {
    if (isEditing) {
      saveValue();
      setSearchValue("");
    }
  }, [saveValue, isEditing]);
  const handleOpenAnimationComplete = useCallback(() => {
    if (isEditing) {
      searchFieldRef.current?.focus();
    }
  }, [isEditing]);
  const handleSearchFieldChange = useCallback(
    (e) => {
      setSearchValue(e.target.value);
    },
    []
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(
      Popover,
      {
        open: isEditing,
        onOpenAnimationComplete: handleOpenAnimationComplete,
        onClickOutside: handleOnClickOutside,
        placement: "bottom-start",
        disableCaret: true,
        children: [
          /* @__PURE__ */ jsx(Popover.Trigger, { children: ({ ref: popoverRef, onKeyDown: triggerOnKeyDown, ...rest }) => {
            return /* @__PURE__ */ jsx(
              TableBodyCell,
              {
                ...restCellProps,
                className: cellClasses,
                onClick,
                children: /* @__PURE__ */ jsx(
                  "button",
                  {
                    ...rest,
                    ref: popoverRef,
                    className: styles$a["data-table-body-cell-select-trigger"],
                    onKeyDown: (e) => handleTriggerKeyDown(e, () => triggerOnKeyDown?.(e)),
                    children
                  }
                )
              }
            );
          } }),
          /* @__PURE__ */ jsx(Popover.Content, { children: /* @__PURE__ */ jsxs(Flex, { gap: "4", direction: "column", children: [
            /* @__PURE__ */ jsx(
              SearchField,
              {
                ref: searchFieldRef,
                onChange: handleSearchFieldChange,
                onKeyDown: handleSearchFieldKeyDown
              }
            ),
            /* @__PURE__ */ jsx(
              ListView,
              {
                defaultSelected: selectedValues,
                onKeyDown: handleListViewKeyDown,
                items: filteredItems,
                onSelectionChange: handleListViewSelectionChange,
                ref: listViewRef,
                children: ({ items }) => items.map((item) => /* @__PURE__ */ jsx(ListView.Option, { item, children: item.label }, item.label))
              }
            )
          ] }) })
        ]
      }
    ),
    /* @__PURE__ */ jsx(SrOnly, { children: isEditing ? "Press F2 to save cell value. Press Escape to cancel." : "Press Enter or F2 to edit cell value." })
  ] });
};

function DataTableBodyCellElement(props) {
  const {
    cellPosition,
    columnId,
    children,
    editMode,
    editValue,
    onChange,
    options,
    rowId,
    ...rest
  } = props;
  const elementRef = useRef(null);
  const tableContext = useDataTableContext();
  useEffect(() => {
    if (elementRef.current) {
      tableContext.registerCell({
        position: cellPosition,
        element: elementRef.current,
        isHeader: false
      });
      return () => {
        tableContext.unregisterCell(cellPosition);
      };
    }
  }, [cellPosition, tableContext]);
  const isEditable = !!editMode;
  const handleFocus = useCallback(() => {
    if (!tableContext.isTableFocused) {
      tableContext.initializeFocus();
      tableContext.focusCell(cellPosition);
    } else if (!isEditable) {
      tableContext.focusCell(cellPosition);
    }
  }, [tableContext, cellPosition, isEditable]);
  const tabIndex = tableContext.getCellTabIndex(cellPosition);
  const classes = cx(styles$9["data-table-body-cell"], rest.className, {
    [styles$9["data-table-body-cell-hovered"]]: tableContext?.hoveredColumnId === columnId
  });
  const commonCellProps = {
    type: "data-table",
    ...rest,
    className: classes,
    ref: elementRef,
    tabIndex,
    onFocus: handleFocus
  };
  if (editMode === "text") {
    return /* @__PURE__ */ jsx(
      DataTableEditableTextCell,
      {
        cellProps: commonCellProps,
        cellPosition,
        rowId,
        onChange,
        value: editValue,
        children
      }
    );
  }
  if (editMode === "select") {
    return /* @__PURE__ */ jsx(
      DataTableEditableSelectCell,
      {
        cellProps: commonCellProps,
        cellPosition,
        rowId,
        value: editValue,
        onChange,
        options,
        children
      }
    );
  }
  if (editMode === "multiselect") {
    return /* @__PURE__ */ jsx(
      DataTableEditableMultiselectCell,
      {
        cellProps: commonCellProps,
        cellPosition,
        rowId,
        value: editValue,
        onChange,
        options,
        children
      }
    );
  }
  return /* @__PURE__ */ jsx(TableBodyCell, { ...commonCellProps, children });
}
const DataTableBodyCell = memo$1(DataTableBodyCellElement);

const styles$8 = {
	"data-table-body-row": "_data-table-body-row_1vs3r_2",
	"data-table-body-sub-component-container": "_data-table-body-sub-component-container_1vs3r_20",
	"data-table-body-sub-component-content": "_data-table-body-sub-component-content_1vs3r_25",
	"data-table-body-cell-group": "_data-table-body-cell-group_1vs3r_31"
};

const DataTableBodyContent = ({
  table
}) => {
  const { hasSubRows } = useDataTableContext();
  return table.getRowModel().rows.map((row, sortedIndex) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      "div",
      {
        role: "row",
        "aria-rowindex": sortedIndex + table.getHeaderGroups().length + 1,
        "aria-expanded": hasSubRows && row.getCanExpand() ? row.getIsExpanded() : void 0,
        "aria-level": hasSubRows && (row.getCanExpand() || row.getParentRow()?.getCanExpand()) ? row.depth + 1 : void 0,
        className: styles$8["data-table-body-row"],
        children: row.getVisibleCells().map((cell) => {
          const isLastInParentGroup = cell.column.parent ? cell.column.parent.getLeafColumns().slice(-1)[0] === cell.column : false;
          const cellClasses = cx(getCommonPinningClasses(cell.column), {
            [styles$8["data-table-body-cell-group"]]: "columns" in cell.column.columnDef || cell.column.parent && isLastInParentGroup
          });
          return /* @__PURE__ */ jsx(
            DataTableBodyCell,
            {
              "aria-colindex": cell.column.getIndex() + 1,
              className: cellClasses,
              style: {
                minWidth: `calc(var(--a2-table-col-${cell.column.getIndex()}-size) * 1px)`,
                ...getCommonPinningStyles(cell.column)
              },
              columnId: cell.column.id,
              cellPosition: {
                rowIndex: sortedIndex + table.getHeaderGroups().length,
                columnIndex: cell.column.getIndex()
              },
              editMode: cell.column.columnDef.meta?.editMode,
              editValue: cell.getContext().getValue(),
              onChange: cell.column.columnDef.meta?.onChange,
              options: cell.column.columnDef.meta?.options,
              rowId: row.id,
              isExpandCell: cell.column.id === "a2-table-internal-expand",
              isSelectCell: cell.column.id === "a2-table-internal-select",
              children: flexRender(cell.column.columnDef.cell, cell.getContext())
            },
            cell.id
          );
        })
      }
    ),
    row.getIsExpanded() && "subComponent" in row.original && /* @__PURE__ */ jsx(
      "div",
      {
        id: `${row.id}-sub-component`,
        "aria-hidden": !row.getIsExpanded(),
        className: styles$8["data-table-body-row"],
        children: /* @__PURE__ */ jsx("div", { className: styles$8["data-table-body-sub-component-container"], children: /* @__PURE__ */ jsx(Flex, { className: styles$8["data-table-body-sub-component-content"], children: row.original.subComponent }) })
      }
    )
  ] }, row.id));
};
function DataTableBody(props) {
  const { table, ...rest } = props;
  return /* @__PURE__ */ jsx(TableBody, { type: "data-table", ...rest, children: /* @__PURE__ */ jsx(DataTableBodyContent, { table }) });
}

const getColSpanWidth = (colSpan, cellIndex) => {
  let minWidth = `calc(var(--a2-table-col-${cellIndex}-size) * 1px)`;
  if (colSpan > 1) {
    const varsToAdd = Array.from(
      { length: colSpan },
      (_, i) => `var(--a2-table-col-${cellIndex + i}-size)`
    );
    minWidth = `calc((${varsToAdd.join(" + ")}) * 1px)`;
  }
  return minWidth;
};

const styles$7 = {
	"table-footer": "_table-footer_hq77m_2"};

function TableFooter({ type, children, ...rest }) {
  const classes = cx(styles$7["table-footer"], rest.className);
  const Element = type === "simple" ? "tfoot" : "div";
  return /* @__PURE__ */ jsx(
    Element,
    {
      ...rest,
      className: classes,
      role: type === "simple" ? void 0 : "rowgroup",
      children
    }
  );
}

const TableFooterCell = forwardRef((props, ref) => {
  const { type, children, className, ...rest } = props;
  const classes = cx(styles$e["table-footer-cell"], className);
  const CellElement = type === "simple" ? "td" : "div";
  return /* @__PURE__ */ jsx(
    CellElement,
    {
      ref,
      "data-anv": "table-footer-cell",
      ...rest,
      className: classes,
      role: type === "simple" ? void 0 : "gridcell",
      children
    }
  );
});
TableFooterCell.displayName = "TableFooterCell";

function DataTableFooterCell(props) {
  const { cellPosition, children, className, ...rest } = props;
  const footerCellRef = useRef(null);
  const tableContext = useDataTableContext();
  useEffect(() => {
    if (footerCellRef.current) {
      tableContext.registerCell({
        position: cellPosition,
        element: footerCellRef.current,
        isHeader: false
      });
      return () => {
        tableContext.unregisterCell(cellPosition);
      };
    }
  }, [cellPosition, tableContext]);
  const handleFocus = useCallback(() => {
    if (!tableContext.isTableFocused) {
      tableContext.initializeFocus();
      tableContext.focusCell(cellPosition);
    }
  }, [cellPosition, tableContext]);
  const tabIndex = tableContext.getCellTabIndex(cellPosition);
  return /* @__PURE__ */ jsx(
    TableFooterCell,
    {
      type: "data-table",
      ...rest,
      ref: footerCellRef,
      tabIndex,
      onFocus: handleFocus,
      className: cx(styles$9["data-table-footer-cell"], className),
      children
    }
  );
}

const styles$6 = {
	"data-table-footer-row": "_data-table-footer-row_1nmuq_2",
	"data-table-footer": "_data-table-footer_1nmuq_2"
};

function DefaultTableFooterRows({
  table,
  columns
}) {
  const findColumnById = (cols, id) => {
    for (const col of cols) {
      if (col.id === id) {
        return col;
      }
      if (col.columns && Array.isArray(col.columns)) {
        const found = findColumnById(col.columns, id);
        if (found) {
          return found;
        }
      }
    }
    return void 0;
  };
  const getMaxFooterRows = (column) => {
    let currentMax = 0;
    if (Array.isArray(column.footerContent)) {
      currentMax = column.footerContent.length;
    } else if (column.footerContent) {
      currentMax = 1;
    }
    if (column.columns && Array.isArray(column.columns)) {
      const nestedMax = Math.max(
        ...column.columns.map((nestedCol) => getMaxFooterRows(nestedCol)),
        0
      );
      currentMax = Math.max(currentMax, nestedMax);
    }
    return currentMax;
  };
  const maxFooterRows = Math.max(
    ...columns.map((column) => getMaxFooterRows(column)),
    1
  );
  return Array.from({ length: maxFooterRows }, (_, rowIndex) => /* @__PURE__ */ jsx(
    "div",
    {
      role: "row",
      "data-anv": "table-footer-row",
      className: styles$6["data-table-footer-row"],
      "aria-rowindex": rowIndex + table.getHeaderGroups().length + table.getRowModel().rows.length + 1,
      children: table.getFlatHeaders().filter((header) => {
        const column = findColumnById(columns, header.column.id);
        return !column?.columns || column.columns.length === 0;
      }).map((header) => {
        const column = findColumnById(columns, header.column.id);
        let footerContent = null;
        if (Array.isArray(column?.footerContent)) {
          footerContent = column.footerContent[rowIndex] || null;
        } else if (column?.footerContent && rowIndex === 0) {
          footerContent = column.footerContent;
        }
        return /* @__PURE__ */ jsx(
          DataTableFooterCell,
          {
            className: getCommonPinningClasses(header.column),
            style: {
              minWidth: `calc(var(--a2-table-col-${header.column.getIndex()}-size) * 1px)`,
              ...getCommonPinningStyles(header.column)
            },
            cellPosition: {
              rowIndex: rowIndex + table.getHeaderGroups().length + table.getRowModel().rows.length,
              columnIndex: header.column.getIndex()
            },
            children: footerContent
          },
          header.id
        );
      })
    },
    `footer-row-${rowIndex}`
  ));
}
function CustomTableFooterRows({
  customFooter,
  columnCount,
  table
}) {
  return customFooter?.map((footerRow, rowIndex) => {
    return /* @__PURE__ */ jsx(
      "div",
      {
        role: "row",
        "data-anv": "table-footer-row",
        className: styles$6["data-table-footer-row"],
        "aria-rowindex": rowIndex + table.getHeaderGroups().length + table.getRowModel().rows.length + 1,
        children: (() => {
          let currentColumnIndex = 0;
          return Array.from({
            length: (
              // total columns
              columnCount - // minus columns merged using colSpan
              footerRow.reduce((acc, curr) => acc + curr.colSpan, 0) + // plus columns added in the custom footer row
              footerRow.length
            )
          }).map((_, index) => {
            const footer = footerRow[index] ?? { content: "", colSpan: 1 };
            const minWidth = getColSpanWidth(
              footer.colSpan,
              currentColumnIndex
            );
            const cell = /* @__PURE__ */ jsx(
              DataTableFooterCell,
              {
                colSpan: footer.colSpan,
                style: {
                  minWidth
                },
                cellPosition: {
                  rowIndex: rowIndex + table.getHeaderGroups().length + table.getRowModel().rows.length,
                  columnIndex: currentColumnIndex
                },
                children: footer.content
              },
              index
            );
            currentColumnIndex += footer.colSpan;
            return cell;
          });
        })()
      },
      rowIndex
    );
  });
}
function DataTableFooter({
  table,
  customFooter,
  columns,
  ...rest
}) {
  const columnCount = table.getFlatHeaders().length;
  const classes = cx(styles$6["data-table-footer"], rest.className);
  return /* @__PURE__ */ jsx(TableFooter, { type: "data-table", ...rest, className: classes, children: customFooter ? /* @__PURE__ */ jsx(
    CustomTableFooterRows,
    {
      table,
      customFooter,
      columnCount
    }
  ) : /* @__PURE__ */ jsx(DefaultTableFooterRows, { table, columns }) });
}

function getTanStackColumnDef({
  columnDef
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
}) {
  const columnHelper = createColumnHelper();
  if (columnDef.columns && columnDef.columns.length > 0) {
    return columnHelper.group({
      id: columnDef.id,
      header: columnDef.headerLabel,
      columns: columnDef.columns.map(
        (column) => getTanStackColumnDef({
          columnDef: column
        })
      ),
      footer: columnDef.footerContent ? () => columnDef.footerContent : void 0,
      enableResizing: columnDef.resizable
    });
  }
  return columnHelper.accessor((row) => row[columnDef.id], {
    id: columnDef.id,
    cell: (info) => {
      if (columnDef.renderCell) {
        const cellContent = columnDef.renderCell(
          info.getValue(),
          info.row.depth
        );
        return /* @__PURE__ */ jsx(
          Flex,
          {
            justifyContent: columnDef.align,
            wrap: "wrap",
            style: {
              width: "100%"
            },
            children: cellContent ?? /* @__PURE__ */ jsx(TableEmptyCellContent, {})
          }
        );
      }
      return /* @__PURE__ */ jsx(
        Flex,
        {
          justifyContent: columnDef.align,
          wrap: "wrap",
          style: {
            width: "100%"
          },
          children: info.getValue() ?? /* @__PURE__ */ jsx(TableEmptyCellContent, {})
        }
      );
    },
    header: () => /* @__PURE__ */ jsx(Flex, { justifyContent: columnDef.align, wrap: "wrap", grow: 1, children: columnDef.headerLabel }),
    footer: columnDef.footerContent ? () => columnDef.footerContent : void 0,
    minSize: columnDef.minWidth,
    maxSize: columnDef.maxWidth,
    enableResizing: columnDef.resizable,
    enableSorting: !!columnDef.sortable,
    meta: {
      editMode: columnDef.editMode,
      onChange: columnDef.onChange,
      options: columnDef.options
    },
    // If custom sorting function is provided, use it
    ...columnDef.sortable && typeof columnDef.sortable === "function" ? {
      sortingFn: (rowA, rowB, colId) => {
        if (typeof columnDef.sortable === "function") {
          return columnDef.sortable(
            rowA.getValue(colId),
            rowB.getValue(colId)
          );
        }
        return 0;
      }
    } : void 0
  });
}

const useColumnOrder = ({ table }) => {
  const getColumnIndexes = useCallback((column) => {
    if (column.columns?.length > 0) {
      return column.columns.map((c) => c.getIndex());
    }
    return [column.getIndex()];
  }, []);
  const columnOrder = useMemo(() => {
    const left = [];
    const right = [];
    const middle = [];
    table.getAllColumns().forEach((column) => {
      if (column.getIsPinned() === "left") {
        left.push(...getColumnIndexes(column));
      } else if (column.getIsPinned() === "right") {
        right.push(...getColumnIndexes(column));
      } else {
        middle.push(...getColumnIndexes(column));
      }
    });
    return left.concat(middle).concat(right);
  }, [table, getColumnIndexes]);
  return {
    columnOrder
  };
};

const useHandleKeyDown = ({
  isTableFocused,
  focusedCell,
  getCellKey,
  cellRefs,
  getSingleFocusableInCell,
  setIsTableFocused,
  setFocusedCell,
  columnOrder,
  focusCell,
  getNextValidPosition,
  table,
  isExpandable,
  isOffGridInteractionOccurring
}) => {
  const handleKeyDown = useCallback(
    (event) => {
      if (!isTableFocused || !focusedCell || isOffGridInteractionOccurring)
        return;
      const currentCellKey = getCellKey(focusedCell);
      const currentCell = cellRefs.current.get(currentCellKey);
      const isOnSingleFocusable = currentCell && getSingleFocusableInCell(currentCell.element) && document.activeElement && currentCell.element.contains(document.activeElement) && document.activeElement !== currentCell.element;
      if (event.key === "Tab" && isOnSingleFocusable) {
        setIsTableFocused(false);
        setFocusedCell(null);
        return;
      }
      if (isExpandable && (event.key === "ArrowLeft" || event.key === "ArrowRight")) {
        const headerRowCount = table.getHeaderGroups().length;
        const bodyRowIndex = focusedCell.rowIndex - headerRowCount;
        if (bodyRowIndex >= 0) {
          const rows = table.getRowModel().rows;
          const currentRow = rows[bodyRowIndex];
          if (currentRow) {
            const canExpand = currentRow.getCanExpand();
            const isExpanded = currentRow.getIsExpanded();
            if (event.key === "ArrowRight" && canExpand && !isExpanded) {
              event.preventDefault();
              currentRow.getToggleExpandedHandler()();
              setTimeout(() => {
                focusCell(focusedCell);
              });
              return;
            } else if (event.key === "ArrowLeft" && canExpand && isExpanded) {
              event.preventDefault();
              currentRow.getToggleExpandedHandler()();
              setTimeout(() => {
                focusCell(focusedCell);
              });
              return;
            }
          }
        }
      }
      let direction = null;
      switch (event.key) {
        case "ArrowUp":
          direction = "up";
          break;
        case "ArrowDown":
          direction = "down";
          break;
        case "ArrowLeft":
          direction = "left";
          break;
        case "ArrowRight":
          direction = "right";
          break;
        case "Home": {
          focusCell({ ...focusedCell, columnIndex: columnOrder[0] });
          event.preventDefault();
          return;
        }
        case "End": {
          focusCell({
            ...focusedCell,
            columnIndex: columnOrder[columnOrder.length - 1]
          });
          event.preventDefault();
          return;
        }
        case "Enter":
        case " ": {
          const currentCellKey2 = getCellKey(focusedCell);
          const currentCell2 = cellRefs.current.get(currentCellKey2);
          if (currentCell2) {
            if (currentCell2.isHeader && currentCell2.sortingHandler) {
              event.preventDefault();
              currentCell2.sortingHandler(event);
              return;
            }
            const singleFocusable = getSingleFocusableInCell(
              currentCell2.element
            );
            if (singleFocusable) {
              event.preventDefault();
              const currentPosition = { ...focusedCell };
              singleFocusable.click();
              setTimeout(() => {
                const cellAfterClick = cellRefs.current.get(currentCellKey2);
                if (cellAfterClick) {
                  const focusableAfterClick = getSingleFocusableInCell(
                    cellAfterClick.element
                  );
                  if (focusableAfterClick) {
                    focusableAfterClick.focus();
                  } else {
                    cellAfterClick.element.focus();
                  }
                  if (focusedCell?.rowIndex !== currentPosition.rowIndex || focusedCell?.columnIndex !== currentPosition.columnIndex) {
                    setFocusedCell(currentPosition);
                  }
                }
              });
              return;
            }
          }
          return;
        }
        default:
          return;
      }
      if (direction) {
        event.preventDefault();
        const nextPosition = getNextValidPosition(focusedCell, direction);
        if (nextPosition) {
          focusCell(nextPosition);
        }
      }
    },
    [
      isTableFocused,
      focusedCell,
      getCellKey,
      cellRefs,
      getSingleFocusableInCell,
      setIsTableFocused,
      setFocusedCell,
      columnOrder,
      focusCell,
      getNextValidPosition,
      table,
      isExpandable,
      isOffGridInteractionOccurring
    ]
  );
  return { handleKeyDown };
};

const useScrollIntoView = ({
  table,
  element
}) => {
  const isScrollingRef = useRef(false);
  const scrollTimeoutRef = useRef();
  const { leftWidth, rightWidth } = useMemo(() => {
    return {
      leftWidth: table.getLeftTotalSize(),
      rightWidth: table.getRightTotalSize()
    };
  }, [table]);
  useEffect(() => {
    if (!element) return;
    const isBodyCell = element.getAttribute("data-anv") === "table-body-cell";
    const scrollContainer = element.closest(
      '[data-anv="table-scroll-container"]'
    );
    const headerElement = scrollContainer.querySelectorAll('[role="rowgroup"]')[0];
    const footerElement = scrollContainer.querySelectorAll('[role="rowgroup"]')[2];
    const stickyDimensions = {
      headerHeight: headerElement.getBoundingClientRect().height,
      footerHeight: footerElement ? footerElement.getBoundingClientRect().height : 0,
      leftWidth,
      rightWidth
    };
    const handleScroll = () => {
      isScrollingRef.current = true;
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
      scrollTimeoutRef.current = window.setTimeout(() => {
        isScrollingRef.current = false;
      }, 150);
    };
    scrollContainer.addEventListener("scroll", handleScroll);
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (!entry.isIntersecting && !isScrollingRef.current) {
          const scrollContainerRect = scrollContainer.getBoundingClientRect();
          const getScrollByLeft = () => {
            if (entry.boundingClientRect.x < scrollContainerRect.x + stickyDimensions.leftWidth) {
              return -stickyDimensions.leftWidth + entry.boundingClientRect.x - scrollContainerRect.x;
            }
            if (entry.boundingClientRect.x + entry.boundingClientRect.width > scrollContainerRect.x + scrollContainerRect.width - stickyDimensions.rightWidth) {
              return element.offsetLeft + (!isBodyCell ? scrollContainerRect.x : 0) + // header/footer have different offsetParent
              entry.boundingClientRect.width - scrollContainerRect.x - scrollContainerRect.width - scrollContainer.scrollLeft + stickyDimensions.rightWidth;
            }
            return 0;
          };
          const getScrollByTop = () => {
            if (!isBodyCell) return 0;
            if (entry.boundingClientRect.y < scrollContainerRect.y + stickyDimensions.headerHeight) {
              return -stickyDimensions.headerHeight + entry.boundingClientRect.y - scrollContainerRect.y;
            }
            if (entry.boundingClientRect.y + entry.boundingClientRect.height > scrollContainerRect.y + scrollContainerRect.height - stickyDimensions.footerHeight) {
              return element.offsetTop + entry.boundingClientRect.height - scrollContainerRect.y - scrollContainerRect.height - scrollContainer.scrollTop + stickyDimensions.footerHeight;
            }
            return 0;
          };
          scrollContainer.scrollBy({
            left: getScrollByLeft(),
            top: getScrollByTop(),
            behavior: "smooth"
          });
        }
      },
      {
        root: scrollContainer,
        rootMargin: `-${stickyDimensions.headerHeight}px -${stickyDimensions.rightWidth}px -${stickyDimensions.footerHeight}px -${stickyDimensions.leftWidth}px 
      `,
        threshold: 1
      }
    );
    observer.observe(element);
    return () => {
      observer.disconnect();
      scrollContainer.removeEventListener("scroll", handleScroll);
      if (isScrollingRef.current) isScrollingRef.current = false;
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
        scrollTimeoutRef.current = void 0;
      }
    };
  }, [element, leftWidth, rightWidth]);
};

const useFocusManagement = (table, isExpandable = false) => {
  const [focusedCell, setFocusedCell] = useState(null);
  const [isTableFocused, setIsTableFocused] = useState(false);
  const [isOffGridInteractionOccurring, setIsOffGridInteractionOccurring] = useState(false);
  const cellRefs = useRef(/* @__PURE__ */ new Map());
  const tableRef = useRef(null);
  const getCellKey = useCallback((position) => {
    return `${position.rowIndex}-${position.columnIndex}`;
  }, []);
  const registerCell = useCallback(
    ({
      position,
      element,
      isHeader = false,
      sortingHandler
    }) => {
      const key = getCellKey(position);
      cellRefs.current.set(key, {
        position,
        element,
        isHeader,
        sortingHandler
      });
    },
    [getCellKey]
  );
  const unregisterCell = useCallback(
    (position) => {
      const key = getCellKey(position);
      cellRefs.current.delete(key);
    },
    [getCellKey]
  );
  const getTotalColumns = useCallback(() => {
    return table.getFlatHeaders().length;
  }, [table]);
  const { columnOrder } = useColumnOrder({ table });
  const getNextValidPosition = useCallback(
    (currentPosition, direction) => {
      const totalColumns = getTotalColumns();
      let newRowIndex = currentPosition.rowIndex;
      let newColumnIndex = currentPosition.columnIndex;
      switch (direction) {
        case "up":
          newRowIndex = currentPosition.rowIndex - 1;
          break;
        case "down":
          newRowIndex = currentPosition.rowIndex + 1;
          break;
        case "left":
        case "right": {
          const currentVisualIndex = columnOrder.indexOf(
            currentPosition.columnIndex
          );
          if (currentVisualIndex === -1) {
            if (direction === "left") {
              newColumnIndex = Math.max(0, currentPosition.columnIndex - 1);
            } else {
              newColumnIndex = Math.min(
                totalColumns - 1,
                currentPosition.columnIndex + 1
              );
            }
          } else {
            let targetVisualIndex;
            if (direction === "left") {
              targetVisualIndex = Math.max(0, currentVisualIndex - 1);
            } else {
              targetVisualIndex = Math.min(
                columnOrder.length - 1,
                currentVisualIndex + 1
              );
            }
            newColumnIndex = columnOrder[targetVisualIndex];
          }
          break;
        }
      }
      if (direction === "up" || direction === "down") {
        if (newRowIndex < 0) {
          return null;
        }
        const targetKey = getCellKey({
          rowIndex: newRowIndex,
          columnIndex: newColumnIndex
        });
        const targetCell = cellRefs.current.get(targetKey);
        if (!targetCell) {
          return null;
        }
      }
      if (newRowIndex === currentPosition.rowIndex && newColumnIndex === currentPosition.columnIndex) {
        return null;
      }
      return { rowIndex: newRowIndex, columnIndex: newColumnIndex };
    },
    [getTotalColumns, getCellKey, columnOrder]
  );
  const getSingleFocusableInCell = useCallback(
    (cellElement) => {
      const focusableElements = cellElement.querySelectorAll(
        'button, input[type="checkbox"], input[type="radio"]'
      );
      if (focusableElements.length === 1) {
        return focusableElements[0];
      }
      return null;
    },
    []
  );
  const updateAllTabIndices = useCallback(
    (newFocusedPosition) => {
      cellRefs.current.forEach((cell, key) => {
        const [rowIndex, columnIndex] = key.split("-").map(Number);
        const isFocusedCell = rowIndex === newFocusedPosition.rowIndex && columnIndex === newFocusedPosition.columnIndex;
        const singleFocusable = getSingleFocusableInCell(cell.element);
        if (singleFocusable) {
          cell.element.tabIndex = isFocusedCell ? 0 : -1;
          singleFocusable.tabIndex = -1;
        } else {
          cell.element.tabIndex = isFocusedCell ? 0 : -1;
        }
      });
    },
    [getSingleFocusableInCell]
  );
  const [cellRef, setCellRef] = useState(void 0);
  useScrollIntoView({ table, element: cellRef });
  const updateCellFocusAndTabIndices = useCallback(
    (cell, position) => {
      setFocusedCell(position);
      requestAnimationFrame(() => {
        updateAllTabIndices(position);
        const singleFocusable = getSingleFocusableInCell(cell.element);
        if (singleFocusable) {
          singleFocusable.focus();
        } else {
          cell.element.focus();
        }
        setCellRef(cell.element);
      });
    },
    [updateAllTabIndices, getSingleFocusableInCell]
  );
  const focusCell = useCallback(
    (position) => {
      const key = getCellKey(position);
      const cell = cellRefs.current.get(key);
      if (cell) {
        updateCellFocusAndTabIndices(cell, position);
      } else {
        requestAnimationFrame(() => {
          const retryCell = cellRefs.current.get(key);
          if (retryCell) {
            updateCellFocusAndTabIndices(retryCell, position);
          }
        });
      }
    },
    [getCellKey, updateCellFocusAndTabIndices]
  );
  const { handleKeyDown } = useHandleKeyDown({
    isTableFocused,
    focusedCell,
    getCellKey,
    cellRefs,
    getSingleFocusableInCell,
    setIsTableFocused,
    setFocusedCell,
    columnOrder,
    isOffGridInteractionOccurring,
    focusCell,
    getNextValidPosition,
    table,
    isExpandable
  });
  const initializeFocus = useCallback(() => {
    setIsTableFocused(true);
    const firstHeaderPosition = { rowIndex: 0, columnIndex: 0 };
    const key = getCellKey(firstHeaderPosition);
    const cell = cellRefs.current.get(key);
    if (cell) {
      updateCellFocusAndTabIndices(cell, firstHeaderPosition);
    }
  }, [getCellKey, updateCellFocusAndTabIndices]);
  const handleTableBlur = useCallback(() => {
    setIsTableFocused(false);
    setFocusedCell(null);
  }, []);
  const getCellTabIndex = useCallback(
    (position) => {
      const key = getCellKey(position);
      const cell = cellRefs.current.get(key);
      if (cell) {
        return cell.element.tabIndex;
      }
      if (!isTableFocused) {
        return position.rowIndex === 0 && position.columnIndex === 0 ? 0 : -1;
      }
      if (!focusedCell) {
        return position.rowIndex === 0 && position.columnIndex === 0 ? 0 : -1;
      }
      return focusedCell.rowIndex === position.rowIndex && focusedCell.columnIndex === position.columnIndex ? 0 : -1;
    },
    [isTableFocused, focusedCell, getCellKey]
  );
  return {
    focusedCell,
    isTableFocused,
    tableRef,
    registerCell,
    unregisterCell,
    handleKeyDown,
    initializeFocus,
    handleTableBlur,
    getCellTabIndex,
    focusCell,
    isOffGridInteractionOccurring,
    setIsOffGridInteractionOccurring
  };
};

function DataTableContextProvider({
  children,
  table,
  hasSubRows
}) {
  const [hoveredColumnId, setHoveredColumnId] = useState(null);
  const focusManagement = useFocusManagement(table, hasSubRows);
  const setHoveredColumnIdNotResizing = useCallback(
    (columnId) => {
      const resizingHandle = document.querySelector(
        '[aria-roledescription="Resize handle"][aria-pressed="true"]'
      );
      if (resizingHandle) {
        return;
      }
      setHoveredColumnId(columnId);
    },
    []
  );
  const contextValue = useMemo(
    () => ({
      hoveredColumnId,
      setHoveredColumnId: setHoveredColumnIdNotResizing,
      focusedCell: focusManagement.focusedCell,
      isTableFocused: focusManagement.isTableFocused,
      registerCell: focusManagement.registerCell,
      unregisterCell: focusManagement.unregisterCell,
      getCellTabIndex: focusManagement.getCellTabIndex,
      handleKeyDown: focusManagement.handleKeyDown,
      initializeFocus: focusManagement.initializeFocus,
      handleTableBlur: focusManagement.handleTableBlur,
      focusCell: focusManagement.focusCell,
      isOffGridInteractionOccurring: focusManagement.isOffGridInteractionOccurring,
      setIsOffGridInteractionOccurring: focusManagement.setIsOffGridInteractionOccurring,
      hasSubRows
    }),
    [
      hoveredColumnId,
      setHoveredColumnIdNotResizing,
      focusManagement.focusedCell,
      focusManagement.isTableFocused,
      focusManagement.registerCell,
      focusManagement.unregisterCell,
      focusManagement.getCellTabIndex,
      focusManagement.handleKeyDown,
      focusManagement.initializeFocus,
      focusManagement.handleTableBlur,
      focusManagement.focusCell,
      focusManagement.isOffGridInteractionOccurring,
      focusManagement.setIsOffGridInteractionOccurring,
      hasSubRows
    ]
  );
  return /* @__PURE__ */ jsx(DataTableContext.Provider, { value: contextValue, children });
}

const SvgArrowUpward = (props) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M13 19V7.83l4.88 4.88c.39.39 1.03.39 1.42 0a.996.996 0 0 0 0-1.41l-6.59-6.59a.996.996 0 0 0-1.41 0l-6.6 6.58a.996.996 0 1 0 1.41 1.41L11 7.83V19c0 .55.45 1 1 1s1-.45 1-1z" }));

const SvgArrowDownward = (props) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M11 5v11.17l-4.88-4.88c-.39-.39-1.03-.39-1.42 0a.996.996 0 0 0 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0l6.59-6.59a.996.996 0 1 0-1.41-1.41L13 16.17V5c0-.55-.45-1-1-1s-1 .45-1 1z" }));

const styles$5 = {
	"table-header": "_table-header_1pe38_2"
};

function TableHeader({ type, children, ...rest }) {
  const classes = cx(styles$5["table-header"], rest.className);
  const Element = type === "simple" ? "thead" : "div";
  return /* @__PURE__ */ jsx(
    Element,
    {
      ...rest,
      className: classes,
      role: type === "simple" ? void 0 : "rowgroup",
      children
    }
  );
}

const TableHeaderCell = forwardRef(
  ({
    type,
    children,
    className,
    isGroup,
    isSortable,
    isSelectCell,
    isExpandCell,
    ...rest
  }, ref) => {
    const classes = cx(styles$e["table-header-cell"], className, {
      [styles$e["table-header-cell-group"]]: isGroup,
      [styles$e["table-header-cell-sortable"]]: isSortable,
      [styles$e["table-cell-internal-expand"]]: isExpandCell,
      [styles$e["table-cell-internal-select"]]: isSelectCell
    });
    const CellElement = type === "simple" ? "th" : "div";
    return /* @__PURE__ */ jsx(
      CellElement,
      {
        ref,
        "data-anv": "table-header-cell",
        ...rest,
        className: classes,
        role: type === "simple" ? void 0 : "columnheader",
        children
      }
    );
  }
);
TableHeaderCell.displayName = "TableHeaderCell";

function DataTableHeaderCell(props) {
  const { cellPosition, children, header, className, ...rest } = props;
  const headerCellRef = useRef(null);
  const tableContext = useDataTableContext();
  useEffect(() => {
    if (headerCellRef.current) {
      const sortingHandler = header.column.columnDef.enableSorting ? header.column.getToggleSortingHandler() : void 0;
      tableContext.registerCell({
        position: cellPosition,
        element: headerCellRef.current,
        isHeader: true,
        sortingHandler
      });
      return () => {
        tableContext.unregisterCell(cellPosition);
      };
    }
  }, [cellPosition, tableContext, header.column]);
  const handleFocus = useCallback(() => {
    if (!tableContext.isTableFocused) {
      tableContext.initializeFocus();
      tableContext.focusCell(cellPosition);
    }
  }, [cellPosition, tableContext]);
  const handleClick = useCallback(
    (event) => {
      if (header.column.columnDef.enableSorting) {
        const target = event.target;
        const resizeHandle = target.closest(
          '[aria-roledescription="Resize handle"]'
        );
        if (resizeHandle) {
          return;
        }
        header.column.getToggleSortingHandler()?.(event);
      }
    },
    [header.column]
  );
  const tabIndex = tableContext.getCellTabIndex(cellPosition);
  return /* @__PURE__ */ jsxs(
    TableHeaderCell,
    {
      type: "data-table",
      ...rest,
      ref: headerCellRef,
      tabIndex,
      onFocus: handleFocus,
      onClick: handleClick,
      className: cx(styles$9["data-table-header-cell"], className),
      "aria-sort": header.column.getIsSorted() === "asc" ? "ascending" : header.column.getIsSorted() === "desc" ? "descending" : void 0,
      children: [
        children,
        header.column.columnDef.enableSorting && /* @__PURE__ */ jsxs(SrOnly, { children: [
          header.column.getIsSorted() === "asc" ? "Sorted ascending." : header.column.getIsSorted() === "desc" ? "Sorted descending." : "Not sorted.",
          " ",
          "Click to toggle sort."
        ] })
      ]
    }
  );
}

const resizing = "_resizing_spw3o_35";
const styles$4 = {
	"resize-handle": "_resize-handle_spw3o_2",
	resizing: resizing
};

function ResizeHandle({ header }) {
  const classes = cx(styles$4["resize-handle"], {
    [styles$4["resizing"]]: header.column.getIsResizing()
  });
  return /* @__PURE__ */ jsx(
    "div",
    {
      role: "button",
      tabIndex: -1,
      onDoubleClick: () => header.column.resetSize(),
      onMouseDown: header.getResizeHandler(),
      onTouchStart: header.getResizeHandler(),
      className: classes,
      "aria-label": "Resize column",
      "aria-pressed": header.column.getIsResizing(),
      "aria-roledescription": "Resize handle"
    }
  );
}

const styles$3 = {
	"data-table-header-row": "_data-table-header-row_blxpc_17"
};

function DataTableHeader({ table }) {
  const { setHoveredColumnId } = useDataTableContext();
  return /* @__PURE__ */ jsx(TableHeader, { type: "data-table", children: table.getHeaderGroups().map((headerGroup, index) => /* @__PURE__ */ jsx(
    "div",
    {
      className: styles$3["data-table-header-row"],
      role: "row",
      "aria-rowindex": index + 1,
      children: headerGroup.headers.map((header) => {
        const isLastInParentGroup = header.column.parent ? header.column.parent.getLeafColumns().slice(-1)[0] === header.column : false;
        const isInternalSelectColumn = header.column.id === "a2-table-internal-select";
        const isInternalExpandColumn = header.column.id === "a2-table-internal-expand";
        const minWidth = getColSpanWidth(
          header.colSpan,
          header.column.columns?.length > 0 ? header.column.columns[0].getIndex() : header.column.getIndex()
        );
        return /* @__PURE__ */ jsx(
          DataTableHeaderCell,
          {
            header: header.getContext(),
            className: getCommonPinningClasses(header.column),
            style: {
              minWidth,
              ...getCommonPinningStyles(header.column)
            },
            "aria-colspan": header.colSpan,
            isGroup: "columns" in header.column.columnDef || header.getContext().header.column.parent && isLastInParentGroup,
            isSortable: header.column.columnDef.enableSorting,
            isSelectCell: isInternalSelectColumn,
            isExpandCell: isInternalExpandColumn,
            onMouseEnter: isInternalExpandColumn || isInternalSelectColumn ? void 0 : () => setHoveredColumnId(header.column.id),
            onMouseLeave: isInternalExpandColumn || isInternalSelectColumn ? void 0 : () => setHoveredColumnId(null),
            cellPosition: {
              rowIndex: index,
              columnIndex: header.column.getIndex()
            },
            children: header.isPlaceholder ? null : /* @__PURE__ */ jsxs(
              Flex,
              {
                direction: "row",
                alignItems: "flex-end",
                gap: 2,
                style: {
                  width: "100%"
                },
                children: [
                  /* @__PURE__ */ jsxs(Flex, { direction: "row", alignItems: "center", gap: 2, grow: 1, children: [
                    flexRender(
                      header.column.columnDef.header,
                      header.getContext()
                    ),
                    {
                      asc: /* @__PURE__ */ jsx(Icon, { svg: SvgArrowUpward, size: "small" }),
                      desc: /* @__PURE__ */ jsx(Icon, { svg: SvgArrowDownward, size: "small" })
                    }[header.column.getIsSorted()] ?? null
                  ] }),
                  header.column.columnDef.enableResizing && /* @__PURE__ */ jsx(ResizeHandle, { header })
                ]
              }
            )
          },
          header.id
        );
      })
    },
    headerGroup.id
  )) });
}

const styles$2 = {
	"table-container": "_table-container_14h5l_2",
	"bg-strong": "_bg-strong_14h5l_53",
	"table-scroll-container": "_table-scroll-container_14h5l_57"
};

const TableContainer = forwardRef(
  (props, ref) => {
    const { layoutStyles, componentProps } = useLayoutPropsUtil(props);
    const {
      children,
      className,
      style,
      background = "default",
      ...rest
    } = componentProps;
    const tableContainerClassNames = cx(className, styles$2["table-container"], {
      [styles$2[`bg-${background}`]]: !!background
    });
    const styleCombined = {
      ...style,
      ...layoutStyles
    };
    return /* @__PURE__ */ jsx(
      "div",
      {
        style: styleCombined,
        ref,
        ...rest,
        className: tableContainerClassNames,
        "data-anv": "table-container",
        children: /* @__PURE__ */ jsx(
          "div",
          {
            className: styles$2["table-scroll-container"],
            "data-anv": "table-scroll-container",
            children
          }
        )
      }
    );
  }
);
TableContainer.displayName = "TableContainer";

const DataTableContainer = forwardRef(({ children, onFocus, onBlur, onKeyDown, tabIndex, ...rest }, ref) => {
  const tableContext = useDataTableContext();
  const handleFocus = (event) => {
    onFocus?.(event);
    if (event.target === event.currentTarget) {
      tableContext.initializeFocus();
    }
  };
  const handleBlur = (event) => {
    onBlur?.(event);
    if (!event.currentTarget.contains(event.relatedTarget)) {
      tableContext.handleTableBlur();
    }
  };
  const handleKeyDown = (event) => {
    onKeyDown?.(event);
    tableContext.handleKeyDown(event);
  };
  return /* @__PURE__ */ jsx(
    TableContainer,
    {
      ref,
      ...rest,
      tabIndex: tabIndex ?? 0,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      children
    }
  );
});
DataTableContainer.displayName = "DataTableContainer";

const pagination = "_pagination_d700v_2";
const styles$1 = {
	pagination: pagination
};

const DataTablePagination = ({
  showCount = true,
  ...props
}) => {
  const { setIsOffGridInteractionOccurring } = useDataTableContext();
  const handleFocus = useCallback(() => {
    setIsOffGridInteractionOccurring(true);
  }, [setIsOffGridInteractionOccurring]);
  const handleBlur = useCallback(() => {
    setIsOffGridInteractionOccurring(false);
  }, [setIsOffGridInteractionOccurring]);
  return /* @__PURE__ */ jsx(
    Pagination,
    {
      className: styles$1["pagination"],
      ...props,
      showCount,
      onFocus: handleFocus,
      onBlur: handleBlur
    }
  );
};

const expanded = "_expanded_1r902_17";
const styles = {
	"container-with-pagination": "_container-with-pagination_1r902_2",
	"footer-with-pagination": "_footer-with-pagination_1r902_5",
	"expand-button": "_expand-button_1r902_8",
	expanded: expanded
};

const useAsyncData = (dataOrPromise) => {
  const [resolvedData, setResolvedData] = useState(null);
  const [error, setError] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  useEffect(() => {
    async function resolveData() {
      if (dataOrPromise instanceof Promise) {
        setIsLoading(true);
        try {
          const data = await dataOrPromise;
          setResolvedData(data);
          setIsLoading(false);
        } catch (_error) {
          setError(true);
          setIsLoading(false);
          setResolvedData(null);
        }
      } else {
        setResolvedData(dataOrPromise);
        setIsLoading(false);
      }
    }
    resolveData();
  }, [dataOrPromise]);
  if (!(dataOrPromise instanceof Promise)) {
    return { data: dataOrPromise, error: false, isLoading: false };
  }
  return { data: resolvedData, error, isLoading };
};

function DataTable(props) {
  const { layoutStyles, componentProps } = useLayoutPropsUtil(props);
  const {
    data: dataProp,
    columns: columnsProp,
    background = "default",
    customFooter,
    defaultExpandedRowIds,
    defaultSelectedRowIds,
    defaultSortedColumn,
    expandedRowIds,
    isSelectable,
    onSelectRow,
    onSort,
    onExpandRow,
    pagination,
    selectedRowIds,
    sortedColumn,
    style,
    ...rest
  } = componentProps;
  const styleCombined = {
    ...style,
    ...layoutStyles
  };
  const [rowSelection, setRowSelection] = useOptionallyControlledState({
    controlledValue: isSelectable && selectedRowIds ? Object.fromEntries(selectedRowIds.map((id) => [id, true])) : void 0,
    defaultValue: isSelectable ? defaultSelectedRowIds ? Object.fromEntries(defaultSelectedRowIds.map((id) => [id, true])) : {} : {},
    onChange: (newRowSelection) => {
      onSelectRow?.(Object.keys(newRowSelection));
    }
  });
  const [sorting, setSorting] = useOptionallyControlledState({
    controlledValue: sortedColumn ? [sortedColumn] : void 0,
    defaultValue: defaultSortedColumn ? [defaultSortedColumn] : void 0,
    onChange: (newSorting) => {
      onSort?.(newSorting[0]);
    }
  });
  const isPaginated = !!pagination;
  const paginationObject = typeof pagination === "object" ? pagination : void 0;
  const rowsPerPage = paginationObject?.rowsPerPage ?? 25;
  const [currentPageIndex, setCurrentPageIndex] = useOptionallyControlledState({
    controlledValue: paginationObject?.currentPageIndex,
    defaultValue: paginationObject?.defaultPageIndex ?? 0,
    onChange: (newPageIndex) => {
      paginationObject?.onPageChange?.(newPageIndex);
    }
  });
  const pageLoader = paginationObject?.loadPageData;
  const isAsyncPaginated = !!pageLoader && typeof pageLoader === "function";
  const dataSource = useMemo(() => {
    if (!isAsyncPaginated) {
      return dataProp;
    }
    return pageLoader({
      pageIndex: currentPageIndex ?? 0,
      pageSize: rowsPerPage
    });
  }, [isAsyncPaginated, currentPageIndex, rowsPerPage, dataProp]);
  const {
    data: resolvedData,
    //TODO: Table should represent error state
    error: _error,
    isLoading
  } = useAsyncData(dataSource);
  const totalItemCount = paginationObject?.totalRowCount ?? resolvedData?.length ?? 0;
  const hasSubRows = !!resolvedData?.some(
    (row) => row?.subRows?.length ?? 0 > 0
  );
  const hasSubComponent = !!resolvedData?.some(
    (row) => row?.subComponent != null
  );
  const isExpandable = hasSubRows || hasSubComponent;
  const [expanded, setExpanded] = useOptionallyControlledState({
    controlledValue: isExpandable && expandedRowIds ? expandedRowIds === "all" ? true : Object.fromEntries(expandedRowIds.map((id) => [id, true])) : void 0,
    defaultValue: isExpandable ? defaultExpandedRowIds ? defaultExpandedRowIds === "all" ? true : Object.fromEntries(defaultExpandedRowIds.map((id) => [id, true])) : {} : {},
    onChange: (newExpanded) => {
      if (newExpanded === true) {
        onExpandRow?.("all");
      } else {
        onExpandRow?.(Object.keys(newExpanded));
      }
    }
  });
  const tableData = useMemo(() => {
    if (isLoading) return [];
    if (!isPaginated || isAsyncPaginated) return resolvedData;
    const maxPageIndex = Math.max(
      0,
      Math.ceil(totalItemCount / rowsPerPage) - 1
    );
    const clampedPageIndex = Math.max(
      0,
      Math.min(currentPageIndex ?? 0, maxPageIndex)
    );
    const startIndex = clampedPageIndex * rowsPerPage;
    const endIndex = startIndex + rowsPerPage;
    return resolvedData?.slice(startIndex, endIndex) ?? [];
  }, [
    isLoading,
    isPaginated,
    isAsyncPaginated,
    resolvedData,
    totalItemCount,
    rowsPerPage,
    currentPageIndex
  ]);
  const columnPinning = useMemo(() => {
    const { left, right } = {
      left: columnsProp.filter((column) => column.pinned === "left").map((c) => String(c.id)),
      right: columnsProp.filter((column) => column.pinned === "right").map((c) => String(c.id))
    };
    const isSelectableOrExpandable = isSelectable || isExpandable;
    const standardPinnedColumns = [];
    if (isSelectable) {
      standardPinnedColumns.push("a2-table-internal-select");
    }
    if (isExpandable) {
      standardPinnedColumns.push("a2-table-internal-expand");
    }
    return {
      left: isSelectableOrExpandable && left && left.length > 0 ? [...standardPinnedColumns, ...left] : left ?? [],
      right: right ?? []
    };
  }, [columnsProp, isSelectable, isExpandable]);
  const columns = useMemo(() => {
    const tableColumns = columnsProp.map(
      (column) => getTanStackColumnDef({
        columnDef: column
      })
    );
    if (isExpandable) {
      tableColumns.unshift({
        id: "a2-table-internal-expand",
        size: 44,
        header: ({ table: table2 }) => {
          return /* @__PURE__ */ jsx(Flex, { grow: 1, justifyContent: "center", children: /* @__PURE__ */ jsx(
            Button,
            {
              onClick: table2.getToggleAllRowsExpandedHandler(),
              appearance: "ghost",
              className: cx(styles["expand-button"], {
                [styles["expanded"]]: table2.getIsAllRowsExpanded()
              }),
              size: "small",
              icon: SvgChevronRight,
              "aria-label": table2.getIsAllRowsExpanded() ? "Collapse all rows" : "Expand all rows"
            }
          ) });
        },
        cell: ({ row }) => {
          if (row.getCanExpand()) {
            return /* @__PURE__ */ jsx(
              Button,
              {
                onClick: row.getToggleExpandedHandler(),
                appearance: "ghost",
                size: "small",
                icon: SvgChevronRight,
                className: cx(styles["expand-button"], {
                  [styles["expanded"]]: row.getIsExpanded()
                }),
                "aria-label": row.getIsExpanded() ? "Collapse row" : "Expand row",
                "aria-expanded": hasSubComponent && row.getCanExpand() ? row.getIsExpanded() : void 0,
                "aria-controls": hasSubComponent && row.getCanExpand() ? `${row.id}-sub-component` : void 0
              }
            );
          } else if (row.getParentRow()?.getCanExpand() && isSelectable) {
            return /* @__PURE__ */ jsx(
              Checkbox,
              {
                "aria-label": row.getIsSelected() ? "Deselect row" : "Select row",
                checked: row.getIsSelected(),
                disabled: !row.getCanSelect(),
                indeterminate: row.getIsSomeSelected(),
                onChange: row.getToggleSelectedHandler()
              }
            );
          }
        }
      });
    }
    if (isSelectable) {
      tableColumns.unshift({
        id: "a2-table-internal-select",
        size: 44,
        header: ({ table: table2 }) => /* @__PURE__ */ jsx(Flex, { grow: 1, justifyContent: "center", children: /* @__PURE__ */ jsx(
          Checkbox,
          {
            "aria-label": table2.getIsAllRowsSelected() ? "Deselect all rows" : "Select all rows",
            checked: table2.getIsAllRowsSelected(),
            indeterminate: table2.getIsSomeRowsSelected(),
            onChange: table2.getToggleAllRowsSelectedHandler()
          }
        ) }),
        cell: ({ row }) => {
          if (row.getParentRow()?.getCanExpand() && isSelectable) {
            return null;
          }
          return /* @__PURE__ */ jsx(
            Checkbox,
            {
              "aria-label": row.getIsSelected() ? "Deselect row" : "Select row",
              checked: row.getIsSelected(),
              disabled: !row.getCanSelect(),
              indeterminate: row.getIsSomeSelected(),
              onChange: row.getToggleSelectedHandler()
            }
          );
        }
      });
    }
    return tableColumns;
  }, [columnsProp, hasSubComponent, isExpandable, isSelectable]);
  const table = useReactTable({
    data: tableData ?? [],
    columns,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getExpandedRowModel: getExpandedRowModel(),
    getGroupedRowModel: getGroupedRowModel(),
    getRowId: (row) => row.id.toString(),
    getSubRows: (row) => row.subRows ?? void 0,
    getRowCanExpand: (row) => {
      const originalRow = row.original;
      return (originalRow?.subRows?.length ?? 0) > 0 || originalRow?.subComponent != null;
    },
    state: {
      columnPinning,
      rowSelection,
      expanded,
      sorting
    },
    columnResizeMode: "onChange",
    enableRowSelection: typeof isSelectable === "function" ? (row) => isSelectable(row.original) : isSelectable,
    onRowSelectionChange: (newRowSelection) => {
      setRowSelection(newRowSelection);
    },
    onExpandedChange: (newExpanded) => {
      setExpanded(newExpanded);
    },
    onSortingChange: (updaterOrValue) => {
      const newSorting = typeof updaterOrValue === "function" ? updaterOrValue(sorting) : updaterOrValue;
      const sortingChanged = JSON.stringify(newSorting) !== JSON.stringify(sorting);
      if (!sortingChanged) {
        return;
      }
      setSorting(newSorting);
    }
  });
  const headers = table.getFlatHeaders();
  const headerRowCount = table.getHeaderGroups().length;
  const bodyRowCount = table.getExpandedRowModel().rows.length;
  const columnSizing = table.getState().columnSizing;
  const getMaxFooterRows = useCallback((column) => {
    let currentMax = 0;
    if (Array.isArray(column.footerContent)) {
      currentMax = column.footerContent.length;
    } else if (column.footerContent) {
      currentMax = 1;
    }
    if (column.columns && Array.isArray(column.columns)) {
      const nestedMax = Math.max(
        ...column.columns.map((nestedCol) => getMaxFooterRows(nestedCol)),
        0
      );
      currentMax = Math.max(currentMax, nestedMax);
    }
    return currentMax;
  }, []);
  const footerLength = useMemo(() => {
    return Math.max(
      ...columnsProp.map((column) => getMaxFooterRows(column)),
      0
    );
  }, [columnsProp, getMaxFooterRows]);
  const hasFooters = footerLength > 0 || customFooter !== void 0 && customFooter.length > 0;
  const rowCount = useMemo(
    () => bodyRowCount + headerRowCount + footerLength,
    [bodyRowCount, headerRowCount, footerLength]
  );
  const cssVars = useMemo(() => {
    const vars = {};
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i];
      vars[`--a2-table-col-${header.column.getIndex()}-size`] = header.column.getSize();
    }
    return vars;
  }, [headers, columnSizing]);
  const columnCount = useMemo(() => {
    return headers.filter((header) => header.subHeaders?.length === 0).length;
  }, [headers]);
  return /* @__PURE__ */ jsx(DataTableContextProvider, { table, hasSubRows, children: /* @__PURE__ */ jsxs(
    DataTableContainer,
    {
      ...rest,
      style: styleCombined,
      background,
      className: pagination ? styles["container-with-pagination"] : void 0,
      children: [
        /* @__PURE__ */ jsxs(
          TableBase,
          {
            type: "data-table",
            style: cssVars,
            rowCount,
            colCount: columnCount,
            hasSubRows,
            children: [
              /* @__PURE__ */ jsx(DataTableHeader, { table }),
              /* @__PURE__ */ jsx(DataTableBody, { table }),
              isLoading && /* @__PURE__ */ jsxs(Fragment, { children: [
                /* @__PURE__ */ jsx(SrOnly, { children: "Loading data. Please wait." }),
                /* @__PURE__ */ jsx(
                  "div",
                  {
                    style: {
                      height: rowsPerPage ? `${rowsPerPage * 35}px` : "200px"
                    },
                    role: "presentation",
                    "aria-hidden": "true",
                    children: /* @__PURE__ */ jsx(
                      Flex,
                      {
                        justifyContent: "center",
                        alignItems: "center",
                        style: {
                          position: "absolute",
                          top: 0,
                          bottom: 0,
                          left: 0,
                          right: 0,
                          margin: "auto",
                          zIndex: 3
                        },
                        children: /* @__PURE__ */ jsx(Spinner, {})
                      }
                    )
                  }
                )
              ] }),
              hasFooters && /* @__PURE__ */ jsx(
                DataTableFooter,
                {
                  className: pagination ? styles["footer-with-pagination"] : void 0,
                  table,
                  columns: columnsProp,
                  customFooter
                }
              )
            ]
          }
        ),
        pagination && /* @__PURE__ */ jsx(
          DataTablePagination,
          {
            itemsPerPage: rowsPerPage,
            showCount: paginationObject?.showCount ?? true,
            page: (currentPageIndex ?? 0) + 1,
            totalItemCount,
            onPageChange: (page) => {
              setCurrentPageIndex(page - 1);
            }
          }
        )
      ]
    }
  ) });
}

export { DataTable as D, chipsFormatter as a, currencyFormatter as b, createColumnHelper$1 as c, percentFormatter as p };
//# sourceMappingURL=DataTable-BkNCMaVu.js.map
