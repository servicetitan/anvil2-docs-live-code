import { jsx, jsxs } from 'react/jsx-runtime';
import { useContext, forwardRef, useRef, useId, useCallback, useEffect, useMemo } from 'react';
import { S as SvgClose } from './close-DZj38AEh.js';
import { T as Text } from './Text-kPA-VzsB.js';
import { B as Button } from './Button-92_FKAyV.js';
import { a as DrawerContext } from './DrawerContext-D4tWTLVf.js';
import { c as childrenToString } from './childrenToString-Bz9MqbHb.js';
import { useTrackingId } from './useTrackingId.js';
import { c as cx } from './index-tZvMCc77.js';
import { a as ToastProvider, b as ToasterPopover, c as ToasterContent } from './Toaster-Dg7M4W4U.js';
import { u as useDialogTransitionStates, a as useKeyboardFocusables, b as useDialogScrollLock, c as useInitialFocus } from './useInitialFocus-Cl_Txu7W.js';
import { r as registerLayer, a as unregisterLayer, b as useOnClickOutside } from './useOnClickOutside-BDzuUjmY.js';
import { u as useMergeRefs } from './useMergeRefs-Dfmtq9cI.js';

import './Drawer.css';const drawer = "_drawer_1enz7_2";
const container = "_container_1enz7_29";
const content = "_content_1enz7_41";
const header = "_header_1enz7_47";
const footer = "_footer_1enz7_70";
const remove = "_remove_1enz7_87";
const large = "_large_1enz7_96";
const sticky = "_sticky_1enz7_99";
const styles = {
	drawer: drawer,
	container: container,
	content: content,
	header: header,
	"close-container": "_close-container_1enz7_63",
	footer: footer,
	remove: remove,
	large: large,
	sticky: sticky,
	"close-button": "_close-button_1enz7_105"
};

function useDrawerContext() {
  const context = useContext(DrawerContext);
  if (!context) {
    throw new Error(
      "useDrawerContext must be used within a DrawerContextProvider"
    );
  }
  return context;
}

const DrawerCancelButton = forwardRef((props, ref) => {
  const { onClick, ...rest } = props;
  const { close } = useDrawerContext();
  const data = {
    children: childrenToString(props.children),
    appearance: props.appearance,
    size: props.size,
    type: props.type
  };
  const trackingId = useTrackingId({
    name: "DrawerCancelButton",
    data,
    hasOverride: !!props["data-tracking-id"]
  });
  const onClickHandler = (e) => {
    onClick?.(e);
    close();
  };
  return /* @__PURE__ */ jsx(
    Button,
    {
      "aria-label": "Close drawer",
      "data-anv": "drawer-cancel-button",
      "data-tracking-id": trackingId,
      onClick: onClickHandler,
      ref,
      ...rest
    }
  );
});
DrawerCancelButton.displayName = "DrawerCancelButton";

const DrawerHeader = forwardRef(
  (props, ref) => {
    const { className, children } = props;
    const data = {
      children: childrenToString(props.children)
    };
    const trackingId = useTrackingId({
      name: "DrawerHeader",
      data,
      hasOverride: !!props["data-tracking-id"]
    });
    const drawerHeaderClasses = cx(styles.header, className);
    return /* @__PURE__ */ jsxs(
      "header",
      {
        className: drawerHeaderClasses,
        "data-anv": "drawer-header",
        "data-tracking-id": trackingId,
        ref,
        children: [
          /* @__PURE__ */ jsx(Text, { variant: "headline", el: "h1", children }),
          /* @__PURE__ */ jsx("span", { className: styles["close-container"], children: /* @__PURE__ */ jsx(
            DrawerCancelButton,
            {
              className: styles["close-button"],
              size: "small",
              appearance: "ghost",
              "aria-label": "Close drawer",
              "data-anv": "drawer-header-close-button",
              icon: SvgClose
            }
          ) })
        ]
      }
    );
  }
);
DrawerHeader.displayName = "DrawerHeader";

const DrawerFooter = forwardRef(
  (props, ref) => {
    const { className, children, sticky = false, ...rest } = props;
    const drawerFooterClasses = cx(styles.footer, className, {
      [styles["sticky"]]: sticky
    });
    return /* @__PURE__ */ jsx(
      "footer",
      {
        className: drawerFooterClasses,
        "data-anv": "drawer-footer",
        ref,
        ...rest,
        children
      }
    );
  }
);
DrawerFooter.displayName = "DrawerFooter";

const DrawerContent = forwardRef(
  (props, ref) => {
    const { className, children, ...rest } = props;
    const drawerContentClasses = cx(styles.content, className);
    return /* @__PURE__ */ jsx(
      "div",
      {
        className: drawerContentClasses,
        "data-anv": "drawer-content",
        ref,
        ...rest,
        children
      }
    );
  }
);
DrawerContent.displayName = "DrawerContent";

const DrawerElement = forwardRef(
  (props, ref) => {
    const {
      className,
      open = false,
      children,
      onOpen,
      onClose,
      // onCancel is destructured so that it is not passed to the dialog in ...rest
      onCancel,
      onKeyDown,
      disableCloseOnEscape = false,
      onClickOutside,
      disableCloseOnClickOutside = false,
      size = "medium",
      enableScrollChaining,
      onOpenAnimationStart,
      onOpenAnimationComplete,
      onCloseAnimationStart,
      onCloseAnimationComplete,
      initialFocusResolver,
      ...rest
    } = props;
    const elRef = useRef(null);
    const contentRef = useRef(null);
    const toasterRef = useRef(null);
    const combinedRef = useMergeRefs([elRef, ref]);
    const id = useId();
    const { state, isOpenOrOpening } = useDialogTransitionStates(elRef, open, {
      onOpenAnimationStart: useCallback(() => {
        onOpenAnimationStart?.();
      }, [onOpenAnimationStart]),
      onOpenAnimationComplete: useCallback(() => {
        onOpenAnimationComplete?.();
        onOpen?.();
      }, [onOpen, onOpenAnimationComplete]),
      onCloseAnimationStart: useCallback(() => {
        onCloseAnimationStart?.();
      }, [onCloseAnimationStart]),
      onCloseAnimationComplete: useCallback(() => {
        onCloseAnimationComplete?.();
      }, [onCloseAnimationComplete])
    });
    const classNames = cx([styles.drawer], className, {
      [styles.remove]: state === "closing",
      [styles.large]: size === "large"
    });
    const { focusables } = useKeyboardFocusables(contentRef, {
      observeChange: false
    });
    const firstFocusable = focusables?.[0];
    const lastFocusable = focusables?.[focusables.length - 1];
    useDialogScrollLock({
      open: isOpenOrOpening,
      id,
      enableScrollChaining,
      elementRef: elRef
    });
    useEffect(() => {
      if (open) {
        registerLayer(id);
      } else {
        unregisterLayer(id);
      }
      return () => {
        unregisterLayer(id);
      };
    }, [open, id]);
    const computeFocus = useCallback((focusables2) => {
      return focusables2.find(
        (focusable) => focusable.dataset.anv !== "drawer-header-close-button"
      ) || focusables2[0];
    }, []);
    useInitialFocus(elRef, {
      computeFocus: initialFocusResolver || computeFocus
    });
    const onCancelHandler = (e) => {
      e.preventDefault();
      if (disableCloseOnEscape) return;
      onClose?.();
    };
    useOnClickOutside({
      onOutsidePress: (e) => {
        if (!open) return;
        onClickOutside?.(e);
      },
      targets: [
        contentRef.current,
        toasterRef.current
      ],
      onClose: () => {
        if (disableCloseOnClickOutside || !open) return;
        onClose?.();
      },
      layerId: id
    });
    const onKeyDownHandler = (e) => {
      onKeyDown?.(e);
      if (e.code === "Tab") {
        if (e.shiftKey && e.target === firstFocusable) {
          e.preventDefault();
          lastFocusable?.focus();
          return;
        }
        if (e.target === lastFocusable && !e.shiftKey) {
          e.preventDefault();
          firstFocusable?.focus();
          return;
        }
      }
    };
    const contextValue = useMemo(() => {
      return { close: () => onClose?.() };
    }, [onClose]);
    return (
      // dialog element does seem to be interactive on MDN guideline
      /* @__PURE__ */ jsxs(
        "dialog",
        {
          className: classNames,
          "data-anv": "drawer",
          "data-anv-scroll-chaining": enableScrollChaining,
          "data-anv-transition-state": state,
          ref: combinedRef,
          onCancel: onCancelHandler,
          onKeyDown: onKeyDownHandler,
          ...rest,
          children: [
            /* @__PURE__ */ jsx(ToastProvider, { isDialogToaster: isOpenOrOpening, children: /* @__PURE__ */ jsx(ToasterPopover, { children: /* @__PURE__ */ jsx(ToasterContent, { id: "drawer-toaster", ref: toasterRef }) }) }),
            /* @__PURE__ */ jsx(DrawerContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsx(
              "section",
              {
                ref: contentRef,
                className: styles.container,
                "data-open": isOpenOrOpening,
                children
              }
            ) })
          ]
        }
      )
    );
  }
);
DrawerElement.displayName = "Drawer";
const Drawer = Object.assign(DrawerElement, {
  /**
   * Header component for the drawer that displays a title and close button.
   *
   * Features:
   * - Displays the drawer title as a headline
   * - Includes an accessible close button
   * - Sticky positioning at the top of the drawer
   * - Proper semantic HTML structure
   * - Accessible with proper ARIA attributes
   * - Consistent styling with the design system
   * - Automatic close functionality
   * - Automatic tracking ID generation for analytics
   *
   * @example
   * <Drawer.Header>Settings</Drawer.Header>
   */
  Header: DrawerHeader,
  /**
   * Footer component for the drawer that displays action buttons and controls.
   *
   * Features:
   * - Flexible layout for action buttons and controls
   * - Optional sticky positioning at the bottom
   * - Proper semantic HTML structure
   * - Accessible with proper ARIA attributes
   * - Consistent styling with the design system
   * - Supports all standard footer element props
   * - Responsive design that adapts to content
   *
   * @example
   * <Drawer.Footer sticky>
   *   <Button onClick={handleSave}>Save</Button>
   *   <Drawer.CancelButton>Cancel</Drawer.CancelButton>
   * </Drawer.Footer>
   */
  Footer: DrawerFooter,
  /**
   * Content container for the drawer that holds the main content area.
   *
   * Features:
   * - Flexible content area with proper spacing
   * - Scrollable content when needed
   * - Proper semantic HTML structure
   * - Accessible with proper ARIA attributes
   * - Consistent styling with the design system
   * - Supports all standard div element props
   * - Responsive design that adapts to content
   * - Proper focus management
   *
   * @example
   * <Drawer.Content>
   *   <p>This is the main content of the drawer.</p>
   *   <p>It can contain any type of content.</p>
   * </Drawer.Content>
   */
  Content: DrawerContent,
  /**
   * A button component that automatically closes the drawer when clicked.
   *
   * Features:
   * - Automatically closes the drawer when clicked
   * - Extends Button component functionality
   * - Accessible with proper ARIA attributes
   * - Consistent styling with the design system
   * - Supports all standard button props
   * - Proper focus management
   * - Can be used anywhere within the drawer context
   * - Automatic tracking ID generation for analytics
   *
   * @example
   * <Drawer.CancelButton appearance="ghost" size="small">
   *   Cancel
   * </Drawer.CancelButton>
   */
  CancelButton: DrawerCancelButton
});

export { Drawer as D, DrawerCancelButton as a, DrawerFooter as b, DrawerHeader as c, DrawerContent as d };
//# sourceMappingURL=Drawer-BLfDJU-e.js.map
