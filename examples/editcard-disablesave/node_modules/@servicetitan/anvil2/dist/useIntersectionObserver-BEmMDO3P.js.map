{"version":3,"file":"useIntersectionObserver-BEmMDO3P.js","sources":["../src/internal/hooks/useIntersectionObserver/useIntersectionObserver.ts"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\n\n/**\n * Internal state type for intersection observer\n * @property {boolean} isIntersecting - Whether the element is intersecting\n * @property {IntersectionObserverEntry} [entry] - The intersection observer entry\n */\ntype State = {\n  /**\n   * Whether the element is intersecting\n   */\n  isIntersecting: boolean;\n  /**\n   * The intersection observer entry\n   */\n  entry?: IntersectionObserverEntry;\n};\n\n/**\n * Options for the useIntersectionObserver hook\n * @property {Element | Document | null} [root] - The root element for intersection calculations\n * @property {string} [rootMargin] - Margin around the root element\n * @property {number | number[]} [threshold] - Threshold values for intersection detection\n * @property {boolean} [freezeOnceVisible] - Whether to freeze once the element becomes visible\n * @property {(isIntersecting: boolean, entry: IntersectionObserverEntry) => void} [onChange] - Callback when intersection changes\n * @property {boolean} [initialIsIntersecting] - Initial intersection state\n */\nexport type UseIntersectionObserverOptions = {\n  /**\n   * The root element for intersection calculations\n   */\n  root?: Element | Document | null;\n  /**\n   * Margin around the root element\n   */\n  rootMargin?: string;\n  /**\n   * Threshold values for intersection detection\n   */\n  threshold?: number | number[];\n  /**\n   * Whether to freeze once the element becomes visible\n   */\n  freezeOnceVisible?: boolean;\n  /**\n   * Callback when intersection changes\n   */\n  onChange?: (\n    isIntersecting: boolean,\n    entry: IntersectionObserverEntry,\n  ) => void;\n  /**\n   * Initial intersection state\n   */\n  initialIsIntersecting?: boolean;\n};\n\n/**\n * Return type for the useIntersectionObserver hook\n * @property {(node?: Element | null) => void} ref - Function to set the element to observe\n * @property {boolean} isIntersecting - Whether the element is intersecting\n * @property {IntersectionObserverEntry} [entry] - The intersection observer entry\n */\nexport type IntersectionReturn = [\n  (node?: Element | null) => void,\n  boolean,\n  IntersectionObserverEntry | undefined,\n] & {\n  ref: (node?: Element | null) => void;\n  isIntersecting: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\n/**\n * Custom hook for observing element intersection with viewport or root element.\n *\n * Features:\n * - Observes element intersection with viewport or custom root element\n * - Supports configurable threshold values and root margins\n * - Provides intersection state and detailed entry information\n * - Supports freezing observation once element becomes visible\n * - Handles browser compatibility gracefully\n * - Provides both array and object destructuring support\n * - Automatically cleans up observer on unmount\n * - Supports onChange callback for custom intersection handling\n *\n * @param options - Configuration options for the intersection observer\n * @returns Array containing ref function, intersection state, and entry, with additional object properties\n */\nexport function useIntersectionObserver({\n  threshold = 0,\n  root = null,\n  rootMargin = \"0%\",\n  freezeOnceVisible = false,\n  initialIsIntersecting = false,\n  onChange,\n}: UseIntersectionObserverOptions = {}): IntersectionReturn {\n  const [ref, setRef] = useState<Element | null>(null);\n\n  const [state, setState] = useState<State>(() => ({\n    isIntersecting: initialIsIntersecting,\n    entry: undefined,\n  }));\n\n  const callbackRef = useRef<UseIntersectionObserverOptions[\"onChange\"]>();\n\n  callbackRef.current = onChange;\n\n  const frozen = state.entry?.isIntersecting && freezeOnceVisible;\n\n  useEffect(() => {\n    // Ensure we have a ref to observe\n    if (!ref) return;\n\n    // Ensure the browser supports the Intersection Observer API\n    if (!(\"IntersectionObserver\" in window)) return;\n\n    // Skip if frozen\n    if (frozen) return;\n\n    let unobserve: (() => void) | undefined;\n\n    const observer = new IntersectionObserver(\n      (entries: IntersectionObserverEntry[]): void => {\n        const thresholds = Array.isArray(observer.thresholds)\n          ? observer.thresholds\n          : [observer.thresholds];\n\n        entries.forEach((entry) => {\n          const isIntersecting =\n            entry.isIntersecting &&\n            thresholds.some(\n              (threshold) => entry.intersectionRatio >= threshold,\n            );\n\n          setState({ isIntersecting, entry });\n\n          if (callbackRef.current) {\n            callbackRef.current(isIntersecting, entry);\n          }\n\n          if (isIntersecting && freezeOnceVisible && unobserve) {\n            unobserve();\n            unobserve = undefined;\n          }\n        });\n      },\n      { threshold, root, rootMargin },\n    );\n\n    observer.observe(ref);\n\n    return () => {\n      observer.disconnect();\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    ref,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    JSON.stringify(threshold),\n    root,\n    rootMargin,\n    frozen,\n    freezeOnceVisible,\n  ]);\n\n  // ensures that if the observed element changes, the intersection observer is reinitialized\n  const prevRef = useRef<Element | null>(null);\n\n  useEffect(() => {\n    if (\n      !ref &&\n      state.entry?.target &&\n      !freezeOnceVisible &&\n      !frozen &&\n      prevRef.current !== state.entry.target\n    ) {\n      prevRef.current = state.entry.target;\n      setState({ isIntersecting: initialIsIntersecting, entry: undefined });\n    }\n  }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\n\n  const result = [\n    setRef,\n    !!state.isIntersecting,\n    state.entry,\n  ] as IntersectionReturn;\n\n  // Support object destructuring, by adding the specific values.\n  result.ref = result[0];\n  result.isIntersecting = result[1];\n  result.entry = result[2];\n\n  return result;\n}\n"],"names":["threshold"],"mappings":"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"}