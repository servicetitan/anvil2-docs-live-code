{"version":3,"file":"TimeField-BkOB5ESa.js","sources":["../src/internal/hooks/usePopoverCloseDelayWorkaround/usePopoverCloseDelayWorkaround.ts","../../hammer-icon/mdi/round/access_time.svg","../src/components/TimeField/internal/constants.ts","../src/components/TimeField/internal/utils/timeFormatting.ts","../src/components/TimeField/internal/utils/timeParsing.ts","../src/components/TimeField/internal/utils/timeOptions.ts","../src/components/TimeField/internal/utils/timeValidation.ts","../src/components/TimeField/internal/utils/timeRounding.ts","../src/components/TimeField/internal/maskito/timePlaceholderMask.ts","../src/components/TimeField/internal/MaskedTimeInput.tsx","../src/components/TimeField/TimeField.tsx"],"sourcesContent":["import { useEffect, useState } from \"react\";\n\n// The Popover continues to render Popover.Content for X milliseconds after the popover is closed.\n// To prevent the popover content from appearing empty, we need to continue to show it inside Popover.Content for X milliseconds.\n// This is just a hack until we have a `onCloseAnimationEnd` prop on Popover.\nexport const usePopoverCloseDelayWorkaround = (\n  popoverOpen: boolean,\n  delay: number = 300,\n) => {\n  const [shouldShowContent, setShouldShowContent] = useState(popoverOpen);\n\n  useEffect(() => {\n    if (!popoverOpen) {\n      const timeout = setTimeout(() => {\n        setShouldShowContent(false);\n      }, delay);\n      return () => clearTimeout(timeout);\n    }\n    setShouldShowContent(true);\n  }, [popoverOpen, delay]);\n\n  return shouldShowContent;\n};\n","import * as React from \"react\";\nconst SvgAccessTime = (props) => /* @__PURE__ */ React.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: \"1em\", height: \"1em\", viewBox: \"0 0 24 24\", ...props }, /* @__PURE__ */ React.createElement(\"path\", { d: \"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm-.22-13h-.06c-.4 0-.72.32-.72.72v4.72c0 .35.18.68.49.86l4.15 2.49c.34.2.78.1.98-.24a.71.71 0 0 0-.25-.99l-3.87-2.3V7.72c0-.4-.32-.72-.72-.72z\" }));\nexport default SvgAccessTime;\n","import { TimeFormat } from \"./types\";\nimport IconAccessTime from \"@servicetitan/hammer-icon/mdi/round/access_time.svg\";\n\n// Time Constants\nexport const TIME_CONSTANTS = {\n  /** Minutes in a full day (24 hours * 60 minutes) */\n  MINUTES_IN_DAY: 1440,\n  /** Maximum hour in 24-hour format */\n  MAX_HOUR_24: 23,\n  /** Maximum minute value */\n  MAX_MINUTE: 59,\n  /** Timeout in milliseconds for input debouncing */\n  INPUT_DEBOUNCE_TIMEOUT: 100,\n} as const;\n\n// Format Constants\nexport const FORMAT_CONSTANTS = {\n  /** 12-hour time format */\n  TWELVE_HOUR: 12 as const,\n  /** 24-hour time format */\n  TWENTY_FOUR_HOUR: 24 as const,\n} as const;\n\n/**\n * Placeholder strings for different time formats.\n */\nexport const TIME_FORMAT_PLACEHOLDERS: Record<TimeFormat, string> = {\n  12: \"––:–– ––\",\n  24: \"––:––\",\n};\n\n/**\n * Clock icon used as prefix in the time input field.\n */\nexport const CLOCK_ICON = IconAccessTime;\n","import { TimeFormat } from \"../types\";\n\n/**\n * Converts hours and minutes to a formatted time string.\n *\n * @param hours - Hours (0-23)\n * @param minutes - Minutes (0-59)\n * @param format - Target format (12 or 24 hour)\n * @returns Formatted time string\n */\nexport function formatTimeString(\n  hours: number,\n  minutes: number,\n  format: TimeFormat,\n): string {\n  // Handle 24:00 edge case\n  if (hours === 24) {\n    hours = 0; // Convert 24:00 to 00:00\n  }\n\n  if (format === 12) {\n    // Convert to 12-hour format\n    let displayHours = hours;\n    let period = \"AM\";\n\n    if (hours === 0) {\n      displayHours = 12;\n    } else if (hours > 12) {\n      displayHours = hours - 12;\n      period = \"PM\";\n    } else if (hours === 12) {\n      period = \"PM\";\n    }\n\n    return `${displayHours.toString().padStart(2, \"0\")}:${minutes.toString().padStart(2, \"0\")} ${period}`;\n  } else {\n    // 24-hour format\n    return `${hours.toString().padStart(2, \"0\")}:${minutes.toString().padStart(2, \"0\")}`;\n  }\n}\n","import { TimeFormat } from \"../types\";\nimport { formatTimeString } from \"./timeFormatting\";\nimport { TIME_CONSTANTS } from \"../constants\";\n\n/**\n * Maximum hour value for 24-hour format.\n */\nexport const MAX_HOUR = TIME_CONSTANTS.MAX_HOUR_24;\n\n/**\n * Maximum minute value.\n */\nexport const MAX_MINUTE = TIME_CONSTANTS.MAX_MINUTE;\n\n/**\n * Converts constraint times to normalized minutes for comparison.\n * Helper to eliminate duplicate constraint conversion logic.\n *\n * @param min - Minimum time constraint\n * @param max - Maximum time constraint\n * @returns Object with minMinutes and maxMinutes for constraint checking\n */\nfunction getConstraintMinutes(min?: string, max?: string) {\n  const minMinutes = min ? timeToMinutes(convertTimeFormat(min, 24)) : 0;\n  const maxMinutes = max\n    ? timeToMinutes(convertTimeFormat(max, 24))\n    : TIME_CONSTANTS.MINUTES_IN_DAY;\n  return { minMinutes, maxMinutes };\n}\n\n/**\n * Checks if time in minutes falls within the given constraints.\n *\n * @param timeMinutes - Time to check in minutes since midnight\n * @param minMinutes - Minimum allowed time in minutes\n * @param maxMinutes - Maximum allowed time in minutes\n * @returns True if time is within constraints\n */\nfunction isWithinConstraints(\n  timeMinutes: number,\n  minMinutes: number,\n  maxMinutes: number,\n): boolean {\n  return timeMinutes >= minMinutes && timeMinutes <= maxMinutes;\n}\n\n/**\n * Converts a time string to total minutes since midnight.\n *\n * @param timeStr - Time string in HH:mm format (24-hour)\n * @returns Total minutes since midnight\n */\nexport const timeToMinutes = (timeStr: string): number => {\n  const match = timeStr.match(/^(\\d{1,2}):(\\d{2})(?:\\s*(AM|PM))?$/i);\n  if (!match) return 0;\n\n  let hours = parseInt(match[1], 10);\n  const minutes = parseInt(match[2], 10);\n  const period = match[3]?.toUpperCase();\n\n  // Validate minutes range\n  if (minutes > MAX_MINUTE) return 0;\n\n  if (period === \"PM\" && hours !== 12) {\n    hours += 12;\n  } else if (period === \"AM\" && hours === 12) {\n    hours = 0;\n  }\n\n  // Validate final hours range (0-23)\n  if (hours > MAX_HOUR) return 0;\n\n  return hours * 60 + minutes;\n};\n\n/**\n * Converts a time string between 12-hour and 24-hour formats.\n *\n * @param time - Time string to convert\n * @param targetFormat - Target format (12 or 24)\n * @returns Converted time string\n */\nexport function convertTimeFormat(\n  time: string,\n  targetFormat: TimeFormat,\n): string {\n  if (!time) return time;\n\n  const minutes = timeToMinutes(time);\n\n  // If timeToMinutes returns 0, it means the input couldn't be parsed as a valid time\n  // Return the original string as the JSDoc comment promises\n  if (minutes === 0 && time !== \"00:00\" && time !== \"12:00 AM\") {\n    return time;\n  }\n\n  const hours = Math.floor(minutes / 60);\n  const mins = minutes % 60;\n\n  return formatTimeString(hours, mins, targetFormat);\n}\n\n/**\n * Normalizes partial time input by adding missing components.\n *\n * @param value - Raw input value\n * @returns Normalized time string\n */\nfunction normalizePartialInput(value: string): string {\n  // Remove placeholder characters first (including en dashes)\n  const cleanValue = value.replace(/[–_:]/g, \"\").replace(/\\s+/g, \"\");\n\n  if (/^\\d{1,2}$/.test(cleanValue)) {\n    // Single or double digit hours, add \":00\"\n    const result = `${cleanValue}:00`;\n    return result;\n  } else if (/^\\d{1,2}:\\d{1}$/.test(cleanValue)) {\n    // Hours and single digit minutes, add \"0\"\n    const result = `${cleanValue}0`;\n    return result;\n  } else if (/^\\d{4}$/.test(cleanValue)) {\n    // Four digits, insert colon after first two\n    const result = `${cleanValue.slice(0, 2)}:${cleanValue.slice(2)}`;\n    return result;\n  } else if (/^\\d{4}(AM|PM)$/i.test(cleanValue)) {\n    // Four digits followed by AM/PM, insert colon after first two\n    const digits = cleanValue.slice(0, 4);\n    const ampm = cleanValue.slice(4);\n    const result = `${digits.slice(0, 2)}:${digits.slice(2)} ${ampm}`;\n    return result;\n  }\n\n  return value;\n}\n\n/**\n * Parses 12-hour format time input.\n *\n * @param normalizedValue - Normalized input value\n * @param min - Minimum allowed time constraint\n * @param max - Maximum allowed time constraint\n * @returns Parsed time components or null if invalid\n */\nfunction parse12HourFormat(\n  normalizedValue: string,\n  min?: string,\n  max?: string,\n): { hours: number; minutes: number } | null {\n  const match = normalizedValue.match(/^(\\d{1,2}):(\\d{1,2})(?:\\s*(AM|PM))?$/i);\n  if (!match) return null;\n\n  let hours = parseInt(match[1], 10);\n  let minutes = parseInt(match[2], 10);\n  const ampm = match[3]?.toUpperCase();\n\n  // Handle partial minute input (e.g., \"10:5\" should be \"10:50\")\n  if (minutes < 10 && normalizedValue.match(/^(\\d{1,2}):(\\d{1})$/)) {\n    minutes *= 10;\n  }\n\n  // Handle AM/PM conversion to 24-hour format\n  if (ampm === \"PM\") {\n    if (hours !== 12) {\n      hours += 12; // Convert to 24-hour (1 PM = 13:00, 2 PM = 14:00, etc.)\n    }\n    // 12 PM stays as 12:00\n  } else if (ampm === \"AM\") {\n    if (hours === 12) {\n      hours = 0; // 12 AM = 00:00\n    }\n    // All other AM times stay as-is\n  } else {\n    // No AM/PM specified - need to choose between AM and PM\n    if (hours === 12) {\n      hours = 12; // 12:00 = 12 PM\n    } else {\n      // For hours 1-11, check constraints to decide AM vs PM\n      if (min || max) {\n        // Check which interpretation (AM or PM) is valid within constraints\n        const amHours = hours;\n        const pmHours = hours + 12;\n\n        const { minMinutes, maxMinutes } = getConstraintMinutes(min, max);\n\n        const amMinutes = amHours * 60 + minutes;\n        const pmMinutes = pmHours * 60 + minutes;\n\n        const amValid = isWithinConstraints(amMinutes, minMinutes, maxMinutes);\n        const pmValid = isWithinConstraints(pmMinutes, minMinutes, maxMinutes);\n\n        if (amValid && pmValid) {\n          // Both are valid, prefer AM (original behavior)\n          // hours stays as-is (AM)\n        } else if (pmValid) {\n          // Only PM is valid, use PM\n          hours = pmHours;\n        } else if (amValid) {\n          // Only AM is valid, use AM\n          // hours stays as-is (AM)\n        } else {\n          // Neither is valid - this should be caught by constraint validation later\n          // hours stays as-is (AM) for now\n        }\n      }\n      // If no constraints, assume AM (original behavior)\n    }\n  }\n\n  return { hours, minutes };\n}\n\n/**\n * Parses 24-hour format time input.\n *\n * @param normalizedValue - Normalized input value\n * @returns Parsed time components or null if invalid\n */\nfunction parse24HourFormat(\n  normalizedValue: string,\n): { hours: number; minutes: number } | null {\n  const match = normalizedValue.match(/^(\\d{1,2}):(\\d{1,2})$/);\n\n  if (!match) {\n    return null;\n  }\n\n  const hours = parseInt(match[1], 10);\n  let minutes = parseInt(match[2], 10);\n\n  // Handle partial minute input (e.g., \"10:5\" should be \"10:50\")\n  if (minutes < 10 && normalizedValue.match(/^(\\d{1,2}):(\\d{1})$/)) {\n    minutes *= 10;\n  }\n\n  const result = { hours, minutes };\n  return result;\n}\n\n/**\n * Validates time constraints for 12-hour format with partial inputs.\n *\n * @param timeString - Formatted time string\n * @param value - Original input value\n * @param min - Minimum allowed time\n * @param max - Maximum allowed time\n * @returns True if time is within constraints\n */\nfunction validate12HourConstraints(\n  timeString: string,\n  value: string,\n  min?: string,\n  max?: string,\n): boolean {\n  if (!min && !max) return true;\n\n  // Check if the original input had AM/PM specified\n  const originalHasAMPM =\n    value.toUpperCase().includes(\"AM\") || value.toUpperCase().includes(\"PM\");\n\n  if (!originalHasAMPM) {\n    // This is a partial input without AM/PM - check if either AM or PM interpretation would be valid\n    // Extract just the time part (HH:MM) without AM/PM\n    const timePart = timeString.replace(/\\s*(AM|PM)$/i, \"\");\n    const amTime = `${timePart} AM`;\n    const pmTime = `${timePart} PM`;\n\n    const amMinutes = timeToMinutes(convertTimeFormat(amTime, 24));\n    const pmMinutes = timeToMinutes(convertTimeFormat(pmTime, 24));\n\n    const { minMinutes, maxMinutes } = getConstraintMinutes(min, max);\n\n    // If either AM or PM interpretation is valid, allow the input\n    return (\n      isWithinConstraints(amMinutes, minMinutes, maxMinutes) ||\n      isWithinConstraints(pmMinutes, minMinutes, maxMinutes)\n    );\n  } else {\n    // AM/PM is specified, check the specific time\n    const timeMinutes = timeToMinutes(convertTimeFormat(timeString, 24));\n    const { minMinutes, maxMinutes } = getConstraintMinutes(min, max);\n\n    return isWithinConstraints(timeMinutes, minMinutes, maxMinutes);\n  }\n}\n\n/**\n * Validates time constraints for 24-hour format.\n *\n * @param timeString - Formatted time string\n * @param min - Minimum allowed time\n * @param max - Maximum allowed time\n * @returns True if time is within constraints\n */\nfunction validate24HourConstraints(\n  timeString: string,\n  min?: string,\n  max?: string,\n): boolean {\n  if (!min && !max) return true;\n\n  const timeMinutes = timeToMinutes(timeString);\n  const { minMinutes, maxMinutes } = getConstraintMinutes(min, max);\n\n  // Check if the exact time is valid\n  if (isWithinConstraints(timeMinutes, minMinutes, maxMinutes)) {\n    return true;\n  }\n\n  // Handle partial inputs - check if this time could potentially be valid\n  // For example, if someone types \"1:00\" but constraints are 09:00-17:00,\n  // we should allow it because they might be typing \"14:00\"\n  const hours = Math.floor(timeMinutes / 60);\n  const minutes = timeMinutes % 60;\n\n  // If this is a partial hour (like \"1:00\"), check if any hour in the valid range\n  // could potentially match this pattern\n  if (minutes === 0) {\n    // Check if any hour in the valid range could start with this digit\n    for (let h = minMinutes; h <= maxMinutes; h += 60) {\n      const potentialHour = Math.floor(h / 60);\n      if (potentialHour.toString().startsWith(hours.toString())) {\n        return true;\n      }\n    }\n  }\n\n  // If this is a partial minute (like \"14:3\"), check if any minute in the valid range\n  // could potentially match this pattern\n  if (\n    hours >= Math.floor(minMinutes / 60) &&\n    hours <= Math.floor(maxMinutes / 60)\n  ) {\n    const hourMinutes = hours * 60;\n    const hourMinMinutes = Math.max(minMinutes, hourMinutes);\n    const hourMaxMinutes = Math.min(maxMinutes, hourMinutes + 59);\n\n    for (let m = hourMinMinutes; m <= hourMaxMinutes; m++) {\n      const potentialMinutes = m % 60;\n      if (potentialMinutes.toString().startsWith(minutes.toString())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Parses input value and converts it to a time string with validation.\n *\n * @param value - The raw input value (may contain placeholders)\n * @param format - The time format (12 or 24 hour)\n * @param removePlaceholder - Function to remove placeholder characters\n * @param min - Minimum allowed time constraint\n * @param max - Maximum allowed time constraint\n * @returns Object containing parsed time string, validation state, and empty state\n */\nexport function parseInputValue(\n  value: string,\n  format: TimeFormat,\n  removePlaceholder: (value: string) => string,\n  min?: string,\n  max?: string,\n) {\n  const valueMinusPlaceholder = removePlaceholder(value);\n\n  if (valueMinusPlaceholder === \"\") {\n    return {\n      time: null,\n      isInputValid: false,\n      isInputEmpty: true,\n    };\n  }\n\n  // Normalize partial inputs\n  const normalizedValue = normalizePartialInput(valueMinusPlaceholder);\n\n  // Parse based on format\n  const parsed =\n    format === 12\n      ? parse12HourFormat(normalizedValue, min, max)\n      : parse24HourFormat(normalizedValue);\n\n  if (!parsed) {\n    return {\n      time: null,\n      isInputValid: false,\n      isInputEmpty: false,\n    };\n  }\n\n  const { hours, minutes } = parsed;\n\n  // Validate hours and minutes\n  if (hours < 0 || hours > MAX_HOUR || minutes < 0 || minutes > MAX_MINUTE) {\n    return {\n      time: null,\n      isInputValid: false,\n      isInputEmpty: false,\n    };\n  }\n\n  // Convert to formatted string\n  const timeString = formatTimeString(hours, minutes, format);\n\n  // Validate constraints\n  const isValid =\n    format === 12\n      ? validate12HourConstraints(timeString, value, min, max)\n      : validate24HourConstraints(timeString, min, max);\n\n  if (!isValid) {\n    return {\n      time: null,\n      isInputValid: false,\n      isInputEmpty: false,\n    };\n  }\n\n  return {\n    time: timeString,\n    isInputValid: true,\n    isInputEmpty: false,\n  };\n}\n","import { TimeFormat } from \"../types\";\nimport { timeToMinutes } from \"./timeParsing\";\nimport { formatTimeString } from \"./timeFormatting\";\nimport { TIME_CONSTANTS, TIME_FORMAT_PLACEHOLDERS } from \"../constants\";\n\n/**\n * Generates time options for the dropdown based on step, min/max constraints, and format.\n *\n * @param step - Time increment in minutes (default 30)\n * @param min - Minimum allowed time as string\n * @param max - Maximum allowed time as string\n * @param format - Time format (12 or 24 hour)\n * @returns Array of time options formatted as strings\n */\nexport function generateTimeOptions({\n  step = 30,\n  min,\n  max,\n  format,\n}: {\n  step?: number;\n  min?: string;\n  max?: string;\n  format: TimeFormat;\n}): string[] {\n  const options: string[] = [];\n\n  const minMinutes = min ? timeToMinutes(min) : 0;\n  const maxMinutes = max\n    ? timeToMinutes(max)\n    : TIME_CONSTANTS.MINUTES_IN_DAY - 1;\n\n  // Generate options at step intervals\n  for (\n    let minutes = 0;\n    minutes < TIME_CONSTANTS.MINUTES_IN_DAY;\n    minutes += step\n  ) {\n    // Skip if outside min/max range\n    if (minutes < minMinutes || minutes > maxMinutes) {\n      continue;\n    }\n\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n\n    options.push(formatTimeString(hours, mins, format));\n  }\n\n  return options;\n}\n\n/**\n * Normalizes a time string by removing special characters and converting to lowercase.\n * Used for fuzzy matching in dropdown filtering.\n *\n * @param str - The time string to normalize\n * @returns Normalized string for comparison\n */\nfunction normalizeTimeString(str: string): string {\n  return str\n    .replace(/[–_:]/g, \"\") // Remove en dashes, underscores, and colons\n    .replace(/\\s+/g, \"\") // Remove spaces\n    .toLowerCase();\n}\n\n/**\n * Filters time options based on user input.\n *\n * @param options - Array of available time options\n * @param userInput - The current user input (after Maskito processing)\n * @returns Filtered array of matching options\n */\nexport function filterTimeOptions(\n  options: string[],\n  userInput: string,\n): string[] {\n  if (\n    !userInput ||\n    userInput === TIME_FORMAT_PLACEHOLDERS[12] ||\n    userInput === TIME_FORMAT_PLACEHOLDERS[24]\n  ) {\n    return options;\n  }\n\n  const normalizedInput = normalizeTimeString(userInput);\n\n  const filtered = options.filter((option) => {\n    const normalizedOption = normalizeTimeString(option);\n    return normalizedOption.startsWith(normalizedInput);\n  });\n\n  return filtered;\n}\n","import { timeToMinutes } from \"./timeParsing\";\nimport { TimeFormat } from \"../types\";\n\n/**\n * Checks if a time aligns with a given step interval.\n *\n * @param time - The time to check\n * @param step - The step increment in minutes\n * @returns True if the time aligns with the step\n */\nexport function isTimeOnStep(time: string, step: number): boolean {\n  if (!step || step <= 0) return true;\n\n  const totalMinutes = timeToMinutes(time);\n  return totalMinutes % step === 0;\n}\n\n/**\n * Checks if a time is valid (exists and can be parsed).\n *\n * @param time - The time to check\n * @returns True if the time is valid\n */\nexport function isValidTime(time: string | null): boolean {\n  if (!time) return false;\n  return timeToMinutes(time) > 0 || time === \"00:00\";\n}\n\n/**\n * Checks if a partial input might become valid as the user continues typing.\n * For example, \"1\" in a 10-11 AM range could become \"10:00 AM\" or \"11:00 AM\".\n * Or \"2\" in a 20:00-23:00 range could become \"20:00\", \"21:00\", etc.\n *\n * @param inputValue - The current input value (may include mask characters)\n * @param format - The time format (12 or 24 hour)\n * @param min - Minimum allowed time constraint\n * @param max - Maximum allowed time constraint\n * @returns True if the partial input could potentially become valid\n */\nexport function isPartialInputPotentiallyValid(\n  inputValue: string,\n  format: TimeFormat,\n  min?: string,\n  max?: string,\n): boolean {\n  // Must have both constraints or neither\n  if (!min || !max) return false;\n\n  // Extract just the digits from the input\n  const digits = inputValue.replace(/[^\\d]/g, \"\");\n\n  // Only handle single digit case - check if it could start a valid hour\n  if (digits.length === 1) {\n    const digit = parseInt(digits, 10);\n\n    // Convert constraints to minutes for easier comparison\n    const minMinutes = timeToMinutes(min);\n    const maxMinutes = timeToMinutes(max);\n\n    // Check all possible hours this digit could represent\n    for (let h = 0; h <= 23; h++) {\n      // Check if this hour starts with our digit (check both padded and unpadded)\n      const hourStr = h.toString().padStart(2, \"0\");\n      const hourStrNoPad = h.toString();\n\n      const startsWithDigit =\n        hourStr.startsWith(digit.toString()) ||\n        hourStrNoPad.startsWith(digit.toString());\n\n      if (!startsWithDigit) continue;\n\n      if (format === 24) {\n        // 24-hour format - simple check\n        const hourMinutes = h * 60;\n        if (hourMinutes >= minMinutes && hourMinutes <= maxMinutes) {\n          return true;\n        }\n      } else {\n        // 12-hour format - check both AM and PM versions\n        if (h === 0) {\n          // Hour 0 = 12 AM (midnight)\n          if (digit === 1) {\n            // \"1\" could be \"12 AM\"\n            const midnightMinutes = 0;\n            if (\n              midnightMinutes >= minMinutes &&\n              midnightMinutes <= maxMinutes\n            ) {\n              return true;\n            }\n          }\n        } else if (h >= 1 && h <= 12) {\n          // Hours 1-12: check both AM and PM\n\n          // AM version\n          const amHour24 = h === 12 ? 0 : h; // 12 AM = hour 0, others stay same\n          const amMinutes = amHour24 * 60;\n          if (amMinutes >= minMinutes && amMinutes <= maxMinutes) {\n            return true;\n          }\n\n          // PM version\n          const pmHour24 = h === 12 ? 12 : h + 12; // 12 PM = hour 12, others add 12\n          const pmMinutes = pmHour24 * 60;\n          if (pmMinutes >= minMinutes && pmMinutes <= maxMinutes) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n","import { TimeFormat } from \"../types\";\nimport { timeToMinutes } from \"./timeParsing\";\nimport { isTimeOnStep, isValidTime } from \"./timeValidation\";\nimport { formatTimeString } from \"./timeFormatting\";\n\n/**\n * Options for auto-rounding functionality.\n */\nexport interface AutoRoundingOptions {\n  /** Whether auto-rounding is enabled. */\n  autoround: boolean;\n  /** Time increment in minutes. */\n  step?: number;\n  /** Time format (12 or 24 hour). */\n  format: TimeFormat;\n}\n\n/**\n * Gets the next future step for a given time based on the step increment.\n *\n * @param time - The current time string\n * @param step - The step increment in minutes\n * @param format - The time format (12 or 24 hour)\n * @returns The next step time string\n */\nexport function getNextFutureStep(\n  time: string,\n  step: number,\n  format: TimeFormat,\n): string {\n  if (!step || step <= 0) return time;\n\n  // Convert time string to minutes\n  const totalMinutes = timeToMinutes(time);\n\n  // Find the next step that's AFTER the current time\n  const nextStep = Math.ceil(totalMinutes / step) * step;\n\n  // Convert back to string format\n  const hours = Math.floor(nextStep / 60);\n  const minutes = nextStep % 60;\n\n  return formatTimeString(hours, minutes, format);\n}\n\n/**\n * Handles auto-rounding of time values based on step intervals.\n *\n * @param time - The time to potentially auto-round\n * @param options - Auto-rounding configuration options\n * @returns The rounded time or the original time if no rounding is needed\n */\nexport function handleAutoRounding(\n  time: string | null,\n  options: AutoRoundingOptions,\n): string | null {\n  const { autoround, step, format } = options;\n\n  if (!autoround || !time) return time;\n\n  // Check if the time is already on a valid step\n  const stepValue = step ?? 30;\n\n  // If the time is already on a valid step, no rounding needed\n  if (isTimeOnStep(time, stepValue)) {\n    return time;\n  }\n\n  // Auto-round to the next step\n  return getNextFutureStep(time, stepValue, format);\n}\n\n/**\n * Generates AM/PM variants for 12-hour format auto-rounding when user hasn't specified AM/PM.\n *\n * @param currentTime - The current time string\n * @param step - Step increment in minutes\n * @param inputValue - Original user input to check for AM/PM specification\n * @returns Array of time options (AM only, PM only, or both)\n */\nexport function generateAmPmVariants(\n  currentTime: string,\n  step: number,\n  inputValue: string,\n): string[] {\n  const hasAM = inputValue.toUpperCase().includes(\"AM\");\n  const hasPM = inputValue.toUpperCase().includes(\"PM\");\n\n  // Helper function to get next step for a given time\n  const getNextStepForTime = (time: string) => {\n    const currentMinutes = timeToMinutes(time);\n    const nextStepMinutes = Math.ceil(currentMinutes / step) * step;\n    const finalMinutes =\n      nextStepMinutes === currentMinutes\n        ? nextStepMinutes + step\n        : nextStepMinutes;\n\n    const hours = Math.floor(finalMinutes / 60);\n    const minutes = finalMinutes % 60;\n    return formatTimeString(hours, minutes, 12);\n  };\n\n  const nextStep = getNextFutureStep(currentTime, step, 12);\n\n  // If user specified AM or PM, only show options in that period\n  if (hasAM || hasPM) {\n    return [nextStep];\n  } else {\n    // User didn't specify AM/PM, show both options\n    // For PM version, add 12 hours to the current time\n    const currentMinutes = timeToMinutes(currentTime);\n    const pmMinutes = currentMinutes + 12 * 60;\n    const pmHours = Math.floor(pmMinutes / 60);\n    const pmMins = pmMinutes % 60;\n    const pmVersion = getNextStepForTime(formatTimeString(pmHours, pmMins, 24));\n    return [nextStep, pmVersion]; // Both AM and PM\n  }\n}\n\n/**\n * Tries to generate PM interpretation options for ambiguous input.\n *\n * @param currentTime - The current time string\n * @param step - Step increment in minutes\n * @param inputValue - Original user input\n * @returns Array of PM time options or empty array\n */\nexport function generatePmInterpretation(\n  currentTime: string,\n  step: number,\n  inputValue: string,\n): string[] {\n  // Only try PM interpretation if no AM/PM was specified\n  if (\n    inputValue.toUpperCase().includes(\"AM\") ||\n    inputValue.toUpperCase().includes(\"PM\")\n  ) {\n    return [];\n  }\n\n  // Try PM version of the current time\n  const currentMinutes = timeToMinutes(currentTime);\n  const pmMinutes = currentMinutes + 12 * 60;\n  const pmHours = Math.floor(pmMinutes / 60);\n  const pmMins = pmMinutes % 60;\n  const pmTime = formatTimeString(pmHours, pmMins, 12);\n\n  // Check if the PM time is valid\n  if (isValidTime(pmTime)) {\n    const pmNextStep = getNextFutureStep(pmTime, step, 12);\n    return [pmNextStep];\n  }\n\n  return [];\n}\n\n/**\n * Gets auto-rounding options for dropdown suggestions when no matches are found.\n *\n * @param currentTime - The current parsed time\n * @param step - Step increment in minutes\n * @param format - Time format (12 or 24 hour)\n * @param inputValue - Original user input\n * @param min - Minimum time constraint\n * @returns Array of auto-rounded time options\n */\nexport function getAutoRoundingOptions(\n  currentTime: string | null,\n  step: number,\n  format: TimeFormat,\n  inputValue: string,\n  min?: string,\n): string[] {\n  if (!currentTime) {\n    return [];\n  }\n\n  // Only add next future step if the current time is valid\n  if (!isValidTime(currentTime)) {\n    // For 12-hour format, try PM interpretation\n    if (format === 12) {\n      return generatePmInterpretation(currentTime, step, inputValue);\n    }\n    return [];\n  }\n\n  const nextStep = getNextFutureStep(currentTime, step, format);\n\n  // For 12-hour format without time range, show AM/PM variants\n  if (format === 12 && !min) {\n    return generateAmPmVariants(currentTime, step, inputValue);\n  }\n\n  return [nextStep];\n}\n","import type { MaskitoOptions } from \"@maskito/core\";\nimport {\n  maskitoTimeOptionsGenerator,\n  maskitoWithPlaceholder,\n} from \"@maskito/kit\";\nimport { TimeFormat } from \"../types\";\n\n/**\n * Creates Maskito options for time input with placeholder support.\n *\n * Features:\n * - Time-specific masking for 12/24 hour formats\n * - Placeholder character support\n * - Filtered preprocessors to avoid conflicts\n * - Combined plugins and postprocessors\n *\n * @param format - The time format (12 or 24 hour)\n * @param placeholder - The placeholder string to use\n * @returns Object containing Maskito options and removePlaceholder function\n */\nconst timePlaceholderMask = ({\n  format,\n  placeholder,\n}: {\n  format: TimeFormat;\n  placeholder: string;\n}) => {\n  // Use Maskito Time Kit for time-specific options\n  const timeOptions = maskitoTimeOptionsGenerator({\n    mode: format === 12 ? \"HH:MM AA\" : \"HH:MM\",\n    step: 0, // We handle step logic in your business layer\n  });\n\n  const { plugins, removePlaceholder, ...placeholderOptions } =\n    maskitoWithPlaceholder(placeholder);\n\n  const timePlaceholderMask = {\n    ...timeOptions,\n    plugins: plugins.concat(timeOptions.plugins || []),\n    preprocessors: [\n      ...placeholderOptions.preprocessors,\n      ...timeOptions.preprocessors,\n    ],\n    postprocessors: [\n      ...timeOptions.postprocessors,\n      ...placeholderOptions.postprocessors,\n    ],\n  } satisfies Required<MaskitoOptions>;\n\n  return { options: timePlaceholderMask, removePlaceholder };\n};\n\nexport default timePlaceholderMask;\n","import {\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { TimeFormat } from \"./types\";\nimport timePlaceholderMask from \"./maskito/timePlaceholderMask\";\nimport { useMaskito } from \"@maskito/react\";\nimport { useMergeRefs } from \"../../../hooks\";\nimport {\n  CLOCK_ICON,\n  TIME_CONSTANTS,\n  TIME_FORMAT_PLACEHOLDERS,\n} from \"./constants\";\nimport { Icon } from \"../../Icon\";\nimport { convertTimeFormat, parseInputValue } from \"./utils/timeParsing\";\nimport { isPartialInputPotentiallyValid } from \"./utils/timeValidation\";\nimport { TextField, TextFieldProps } from \"../../TextField/internal/TextField\";\n\nimport cx from \"classnames\";\nimport styles from \"../TimeField.module.scss\";\n\n/**\n * Change event data for MaskedTimeInput onInputChange callback.\n */\nexport type MaskedTimeInputChange = {\n  /**\n   * The original input change event.\n   */\n  event: React.ChangeEvent<HTMLInputElement>;\n  /**\n   * The parsed time as a string if valid, otherwise null.\n   */\n  time: string | null;\n  /**\n   * True if the input matches the mask and is not empty.\n   */\n  isInputValid: boolean;\n  /**\n   * True if the input is empty.\n   */\n  isInputEmpty: boolean;\n};\n\n/**\n * Props for the MaskedTimeInput component.\n * @extends Omit<TextFieldProps, \"onChange\" | \"value\" | \"ref\" | \"showCounter\" | \"prefix\" | \"type\" | \"maxLength\" | \"hint\">\n */\nexport interface MaskedTimeInputProps\n  extends Omit<\n    TextFieldProps,\n    | \"onChange\"\n    | \"value\"\n    | \"ref\"\n    | \"showCounter\"\n    | \"prefix\"\n    | \"type\"\n    | \"maxLength\"\n    | \"hint\"\n  > {\n  /**\n   * External time selection from dropdown\n   */\n  selectedTime?: string | null;\n  /**\n   * The time format (12 or 24 hour).\n   */\n  format: TimeFormat;\n  /**\n   * The placeholder string for the input.\n   */\n  placeholder: string;\n  /**\n   * Minimum allowed time constraint.\n   */\n  min?: string;\n  /**\n   * Maximum allowed time constraint.\n   */\n  max?: string;\n  /**\n   * Callback fired when the input value changes.\n   */\n  onInputChange?: (change: MaskedTimeInputChange) => void;\n  /**\n   * Callback fired when a key is pressed.\n   */\n  onKeyDown?: (event: React.KeyboardEvent<HTMLInputElement>) => void;\n  /**\n   * Callback fired when the input receives focus.\n   */\n  onFocus?: (event: React.FocusEvent<HTMLInputElement>) => void;\n  /**\n   * Data attribute indicating if the current input is valid.\n   */\n  \"data-input-valid\"?: boolean;\n}\n\n/**\n * A masked time input component for entering time in 12/24 hour format.\n *\n * Features:\n * - Input masking and placeholder using Maskito\n * - Smart validation and parsing\n * - Hard-coded clock icon prefix\n * - Controlled or uncontrolled usage\n * - Automatic time format conversion\n * - Placeholder handling and cleanup\n *\n * @example\n * <MaskedTimeInput\n *   selectedTime=\"14:30\"\n *   format={24}\n *   placeholder=\"––:––\"\n *   onInputChange={(change) => {\n *     console.log('Input changed:', change.time);\n *   }}\n * />\n */\nexport const MaskedTimeInput = forwardRef<\n  HTMLInputElement,\n  MaskedTimeInputProps\n>(\n  (\n    {\n      selectedTime,\n      format,\n      placeholder,\n      min,\n      max,\n      onInputChange,\n      onKeyDown,\n      onFocus,\n      onBlur,\n      className,\n      ...props\n    },\n    ref,\n  ) => {\n    const [inputValue, setInputValue] = useState(placeholder);\n\n    const { options, removePlaceholder } = timePlaceholderMask({\n      format,\n      placeholder,\n    });\n    const maskedInputRef = useMaskito({ options });\n    const inputRef = useRef<HTMLInputElement>(null);\n    const combinedRef = useMergeRefs([maskedInputRef, inputRef, ref]);\n    const isUserTypingRef = useRef(false);\n    const inputValueRef = useRef<string>(placeholder);\n    const previousPlaceholderRef = useRef<string>(placeholder);\n\n    // Parse current input value - following DateFields pattern\n    const currentParsedData = useMemo(() => {\n      return parseInputValue(inputValue, format, removePlaceholder, min, max);\n    }, [inputValue, format, removePlaceholder, min, max]);\n\n    // Update refs when values change\n    useEffect(() => {\n      inputValueRef.current = inputValue;\n    }, [inputValue]);\n\n    useEffect(() => {\n      previousPlaceholderRef.current = placeholder;\n    }, [placeholder]);\n\n    // Handle external selectedTime updates (e.g., from dropdown selections)\n    useEffect(() => {\n      if (selectedTime !== undefined && !isUserTypingRef.current) {\n        const newInputValue = selectedTime\n          ? convertTimeFormat(selectedTime, format)\n          : placeholder;\n\n        setInputValue(newInputValue);\n        inputValueRef.current = newInputValue;\n      }\n    }, [selectedTime, format, placeholder]);\n\n    // Handle placeholder changes\n    useEffect(() => {\n      // Only run when placeholder actually changes\n      if (placeholder === previousPlaceholderRef.current) return;\n\n      // Only update if input is actually a placeholder\n      const isOldPlaceholder =\n        inputValue === TIME_FORMAT_PLACEHOLDERS[12] ||\n        inputValue === TIME_FORMAT_PLACEHOLDERS[24];\n\n      if (isOldPlaceholder) {\n        setInputValue(placeholder);\n      }\n\n      previousPlaceholderRef.current = placeholder;\n    }, [placeholder, inputValue]);\n\n    const handleChange = useCallback(\n      (event: React.ChangeEvent<HTMLInputElement>) => {\n        isUserTypingRef.current = true;\n\n        const { time, isInputValid, isInputEmpty } = parseInputValue(\n          event.target.value,\n          format,\n          removePlaceholder,\n          min,\n          max,\n        );\n\n        // Check if this might be a potentially valid partial input\n        const isPotentiallyValidPartial =\n          !isInputValid &&\n          !isInputEmpty &&\n          event.target.value.length >= placeholder.length && // User is typing, not deleting\n          isPartialInputPotentiallyValid(event.target.value, format, min, max);\n\n        // Only update the input value if it's valid, empty, or potentially valid partial\n        if (isInputValid || isInputEmpty || isPotentiallyValidPartial) {\n          setInputValue(event.target.value);\n        } else {\n          // Reset to placeholder when input is invalid to clear the mask's internal state\n          setInputValue(placeholder);\n        }\n\n        onInputChange?.({\n          event,\n          time,\n          isInputValid,\n          isInputEmpty,\n        });\n\n        // Reset typing flag after a delay\n        setTimeout(() => {\n          isUserTypingRef.current = false;\n        }, TIME_CONSTANTS.INPUT_DEBOUNCE_TIMEOUT);\n      },\n      [format, removePlaceholder, onInputChange, min, max, placeholder],\n    );\n\n    const resetTypingFlag = useCallback(() => {\n      isUserTypingRef.current = false;\n    }, []);\n\n    // Handle auto-completion on blur\n    const handleBlur = useCallback(\n      (event: React.FocusEvent<HTMLInputElement>) => {\n        // Auto-complete if we have a valid parsed time\n        if (currentParsedData.time && currentParsedData.isInputValid) {\n          const completedValue = convertTimeFormat(\n            currentParsedData.time,\n            format,\n          );\n          setInputValue(completedValue);\n        }\n\n        // Call parent's blur handler if provided\n        onBlur?.(event);\n      },\n      [currentParsedData, format, onBlur],\n    );\n\n    useImperativeHandle(ref, () => {\n      const input = inputRef.current;\n      if (!input)\n        return null as unknown as HTMLInputElement & {\n          resetTypingFlag: () => void;\n        };\n      return Object.assign(input, {\n        resetTypingFlag,\n      });\n    });\n\n    const classNames = useMemo(() => {\n      return cx(styles[\"time-field\"], className);\n    }, [className]);\n\n    return (\n      <TextField\n        ref={combinedRef}\n        data-input-valid={currentParsedData.isInputValid}\n        data-input-empty={currentParsedData.isInputEmpty}\n        data-time={currentParsedData.time ?? \"\"}\n        value={inputValue}\n        onChange={handleChange}\n        prefix={<Icon svg={CLOCK_ICON} />}\n        autoComplete=\"off\"\n        onKeyDown={onKeyDown}\n        onFocus={onFocus}\n        onBlur={handleBlur}\n        className={classNames}\n        {...props}\n      />\n    );\n  },\n);\n\nMaskedTimeInput.displayName = \"MaskedTimeInput\";\n","import {\n  RefObject,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { useTrackingId, useMergeRefs } from \"../../hooks\";\nimport { DataTrackingId } from \"../../types\";\nimport { TextFieldProps } from \"../TextField\";\nimport { TimeFieldChangeHandler, TimeFormat } from \"./internal/types\";\nimport { childrenToString } from \"../../internal/functions\";\nimport {\n  useLayoutPropsUtil,\n  useOptionallyControlledState,\n  usePopoverCloseDelayWorkaround,\n  usePopoverSupport,\n} from \"../../internal/hooks\";\nimport { TIME_FORMAT_PLACEHOLDERS } from \"./internal/constants\";\nimport {\n  filterTimeOptions,\n  generateTimeOptions,\n} from \"./internal/utils/timeOptions\";\nimport {\n  getAutoRoundingOptions,\n  handleAutoRounding,\n} from \"./internal/utils/timeRounding\";\nimport {\n  MaskedTimeInput,\n  MaskedTimeInputChange,\n} from \"./internal/MaskedTimeInput\";\nimport Popover from \"../Popover\";\nimport Listbox from \"../Listbox\";\n\n/**\n * Props for the TimeField component.\n * @extends Omit<TextFieldProps, \"onChange\" | \"value\" | \"defaultValue\" | \"type\" | \"min\" | \"max\" | \"step\" | \"maxLength\" | \"showCounter\">\n */\nexport type TimeFieldProps = Omit<\n  TextFieldProps,\n  | \"onChange\"\n  | \"value\"\n  | \"defaultValue\"\n  | \"type\"\n  | \"min\"\n  | \"max\"\n  | \"step\"\n  | \"maxLength\"\n  | \"showCounter\"\n  | \"prefix\"\n> & {\n  /**\n   * The current value of the time field.\n   * @example \"14:30\" or \"02:30 PM\"\n   */\n  value?: string | null;\n  /**\n   * The default value for uncontrolled mode.\n   * @example \"14:30\" or \"02:30 PM\"\n   */\n  defaultValue?: string | null;\n  /**\n   * Callback when the time value changes.\n   */\n  onChange?: TimeFieldChangeHandler;\n  /**\n   * Time format to use.\n   * @default 12\n   */\n  format?: TimeFormat;\n  /**\n   * Time increment in minutes.\n   * @default 30\n   */\n  step?: number;\n  /**\n   * Whether to automatically round to the nearest step.\n   * @default false\n   */\n  autoround?: boolean;\n  /**\n   * Whether to disable the dropdown suggestions.\n   * @default false\n   */\n  disableSuggestions?: boolean;\n} & (\n    | {\n        /**\n         * Minimum allowed time constraint.\n         * @example \"09:00 AM\" or \"09:00\"\n         */\n        min: string;\n        /**\n         * Maximum allowed time constraint.\n         * @example \"05:00 PM\" or \"17:00\"\n         */\n        max: string;\n      }\n    | {\n        min?: never;\n        max?: never;\n      }\n  ) &\n  DataTrackingId;\n\n/**\n * TimeField component for entering time values with auto-rounding and suggestions.\n *\n * Features:\n * - Supports 12-hour and 24-hour time formats\n * - Min/max time constraints handled during input parsing\n * - Auto-rounding to step intervals when autoround is true\n * - Dropdown suggestions for quick time selection\n * - Controlled and uncontrolled modes\n * - Smart input masking with placeholders\n * - Integration with MaskedTimeInput for auto-complete\n * - Validation handled by implementors using onChange callback\n * - Automatic tracking ID generation for analytics\n *\n * @example\n * <TimeField\n *   label=\"Meeting Time\"\n *   value=\"14:30\"\n *   format={24}\n *   step={30}\n *   min=\"09:00\"\n *   max=\"17:00\"\n *   autoround\n *   disableSuggestions\n *   onChange={(change) => {\n *     // Handle time change and validation\n *     if (change.isInputEmpty && required) {\n *       // Show required error\n *     }\n *   }}\n * />\n */\nexport const TimeField = (props: TimeFieldProps) => {\n  const { componentProps } = useLayoutPropsUtil(props);\n  const {\n    label,\n    labelProps,\n    size,\n    value: valueProp,\n    defaultValue,\n    min,\n    max,\n    onChange,\n    format = 12,\n    step = 30,\n    required,\n    description,\n    error: errorProp,\n    disableSuggestions = false,\n    autoround = false,\n    className,\n    ...rest\n  } = componentProps;\n\n  // Dropdown state management\n  const [isDropdownOpen, setIsDropdownOpenRaw] = useState(false);\n\n  const setIsDropdownOpen = (open: boolean) => {\n    setIsDropdownOpenRaw(open);\n  };\n  const [selectedOptionIndex, setSelectedOptionIndex] = useState(0);\n  const [inputValueForFiltering, setInputValueForFiltering] = useState(\"\");\n  const [currentParsedTime, setCurrentParsedTime] = useState<string | null>(\n    null,\n  );\n\n  // Controlled state for the visual input value when an option is selected from dropdown\n  const [selectedTime, setSelectedTime] = useOptionallyControlledState<\n    string | null\n  >({\n    controlledValue: valueProp,\n    defaultValue: defaultValue ?? null,\n  });\n\n  // Get parsed data from MaskedTimeInput via data attributes\n  const [inputParsedData, setInputParsedData] = useState<{\n    time: string | null;\n    isInputValid: boolean;\n    isInputEmpty: boolean;\n  }>({ time: null, isInputValid: false, isInputEmpty: true });\n\n  // Track the last onChange call to prevent duplicate calls\n  const lastOnChangeCallRef = useRef<{\n    time: string | null;\n    isInputValid: boolean;\n    isInputEmpty: boolean;\n  } | null>(null);\n\n  // Track if dropdown is being clicked (vs tabbed to)\n  const isDropdownClickingRef = useRef(false);\n\n  // Track if we just made a selection (to prevent auto-reopening on focus)\n  const [justSelected, setJustSelected] = useState(false);\n\n  // Track if Tab was just pressed (to prevent useEffect from reopening dropdown)\n  const tabJustPressedRef = useRef(false);\n\n  // Popover support and refs\n  const inputRef = useRef<\n    HTMLInputElement & {\n      resetTypingFlag?: () => void;\n    }\n  >(null);\n  const popoverContentRef = useRef<HTMLDivElement>(null);\n  const [popoverTriggerRef, setPopoverTriggerRef] =\n    useState<RefObject<HTMLInputElement>>();\n  const combinedRef = useMergeRefs([popoverTriggerRef, inputRef]);\n\n  const popoverSupported = usePopoverSupport();\n\n  // Get placeholder based on format\n  const placeholder = TIME_FORMAT_PLACEHOLDERS[format];\n\n  // Optimize dropdown rendering - only show options when dropdown is open\n  const shouldShowOptionsFromHook =\n    usePopoverCloseDelayWorkaround(isDropdownOpen);\n\n  // Override the delay when Tab was just pressed to prevent empty popover\n  const shouldShowOptions = tabJustPressedRef.current\n    ? false\n    : shouldShowOptionsFromHook;\n\n  // Cleanup timeouts on unmount\n  const dropdownTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Cleanup timeouts when component unmounts\n  useEffect(() => {\n    const dropdownRef = dropdownTimeoutRef.current;\n    return () => {\n      if (dropdownRef) {\n        clearTimeout(dropdownRef);\n      }\n    };\n  }, []);\n\n  // Generate time options for dropdown\n  const allTimeOptions = useMemo(\n    () => generateTimeOptions({ step, min, max, format }),\n    [step, min, max, format],\n  );\n\n  // Split the complex filtering logic into focused memos\n  const baseFilteredOptions = useMemo(() => {\n    // If no input or placeholder, show all options\n    if (!inputValueForFiltering || inputValueForFiltering.match(/^[–_:]+$/)) {\n      return allTimeOptions;\n    }\n\n    return filterTimeOptions(allTimeOptions, inputValueForFiltering);\n  }, [allTimeOptions, inputValueForFiltering]);\n\n  const autoRoundingOptions = useMemo(() => {\n    // Only generate auto-rounding options if enabled and no base matches\n    if (\n      !autoround ||\n      baseFilteredOptions.length > 0 ||\n      !inputValueForFiltering ||\n      inputValueForFiltering.match(/^[–_:]+$/)\n    ) {\n      return [];\n    }\n\n    // Get current time for auto-rounding logic\n    const currentTime = currentParsedTime || inputParsedData.time;\n\n    const autoRoundedOptions = getAutoRoundingOptions(\n      currentTime,\n      step ?? 30,\n      format,\n      inputValueForFiltering,\n      min,\n    );\n\n    // Filter out any options that are already in baseFiltered\n    return autoRoundedOptions.filter(\n      (option) => !baseFilteredOptions.includes(option),\n    );\n  }, [\n    autoround,\n    baseFilteredOptions,\n    inputValueForFiltering,\n    currentParsedTime,\n    inputParsedData.time,\n    format,\n    min,\n    step,\n  ]);\n\n  const filteredOptions = useMemo(() => {\n    // If input is completely invalid AND we have no matches, show all options\n    if (baseFilteredOptions.length === 0 && autoRoundingOptions.length === 0) {\n      if (\n        !inputParsedData.isInputValid &&\n        inputValueForFiltering &&\n        !inputValueForFiltering.match(/^[–_:]+$/)\n      ) {\n        return allTimeOptions;\n      }\n    }\n\n    return [...baseFilteredOptions, ...autoRoundingOptions];\n  }, [\n    baseFilteredOptions,\n    autoRoundingOptions,\n    allTimeOptions,\n    inputValueForFiltering,\n    inputParsedData.isInputValid,\n  ]);\n\n  // Handle blur - close dropdown and validate current input state\n  const handleBlur = useCallback(\n    (event: React.FocusEvent<HTMLInputElement>) => {\n      // Skip blur processing if clicking in the dropdown (prevents duplicate onChange)\n      // but allow blur for other cases like tabbing away\n      if (\n        event.relatedTarget &&\n        popoverContentRef.current?.contains(event.relatedTarget as Node) &&\n        isDropdownClickingRef.current\n      ) {\n        isDropdownClickingRef.current = false; // Reset flag\n        return;\n      }\n\n      // Close dropdown on blur\n      setIsDropdownOpen(false);\n      setSelectedOptionIndex(0);\n\n      // Get parsed data from MaskedTimeInput data attributes - following DateFields pattern\n      const input = event.target as HTMLInputElement;\n      const parsedInputTime = input.dataset.time || null;\n      const isInputValid = input.dataset.inputValid === \"true\";\n      const isInputEmpty = input.dataset.inputEmpty === \"true\";\n\n      // Use the parsed input time directly, don't fall back to old values\n      let finalTime = parsedInputTime;\n\n      // Auto-rounding logic - apply when autoround is enabled regardless of suggestions\n      if (autoround && finalTime && isInputValid) {\n        const beforeRounding = finalTime;\n        finalTime = handleAutoRounding(finalTime, {\n          autoround,\n          step,\n          format,\n        });\n\n        // If auto-rounding changed the time, update the visual input\n        if (finalTime !== beforeRounding) {\n          inputRef.current?.resetTypingFlag?.();\n          setSelectedTime(finalTime);\n        }\n      }\n\n      // Check if this onChange call would be a duplicate\n      const currentChange = {\n        time: finalTime,\n        isInputValid,\n        isInputEmpty,\n      };\n\n      const lastChange = lastOnChangeCallRef.current;\n      const isDuplicate =\n        lastChange &&\n        lastChange.time === currentChange.time &&\n        lastChange.isInputValid === currentChange.isInputValid &&\n        lastChange.isInputEmpty === currentChange.isInputEmpty;\n\n      // Only call onChange if this is not a duplicate\n      if (!isDuplicate) {\n        onChange?.(currentChange);\n        lastOnChangeCallRef.current = currentChange;\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [format, step, autoround, onChange],\n  );\n\n  // Add focus handler\n  const handleFocus = useCallback(() => {\n    if (!disableSuggestions && !justSelected) {\n      setIsDropdownOpen(true);\n      // Don't automatically select the first option on focus\n      // This allows the input to remain empty when user just focuses\n      setSelectedOptionIndex(0);\n    }\n  }, [disableSuggestions, justSelected]);\n\n  // Handle dropdown state based on filtered options\n  useEffect(() => {\n    // Close dropdown if no options available or only 1 option (no choice to make)\n    if (filteredOptions.length <= 1 && isDropdownOpen) {\n      setIsDropdownOpen(false);\n    }\n\n    // Reopen dropdown when multiple options become available while input is focused\n    if (\n      !disableSuggestions &&\n      filteredOptions.length > 1 &&\n      document.activeElement &&\n      document.activeElement.tagName === \"INPUT\" &&\n      !isDropdownOpen &&\n      !justSelected &&\n      !tabJustPressedRef.current\n    ) {\n      setIsDropdownOpen(true);\n      setSelectedOptionIndex(0);\n    }\n  }, [filteredOptions, disableSuggestions, isDropdownOpen, justSelected]);\n\n  // Handle input changes from MaskedTimeInput\n  const handleInputChange = (change: MaskedTimeInputChange) => {\n    // Update input value for filtering\n    setInputValueForFiltering(change.event.target.value);\n\n    // Update current parsed time for auto-rounding logic\n    setCurrentParsedTime(change.time);\n\n    // Update parsed data state from the change event\n    setInputParsedData({\n      time: change.time,\n      isInputValid: change.isInputValid,\n      isInputEmpty: change.isInputEmpty,\n    });\n\n    // Reset selected option index when user types\n    setSelectedOptionIndex(0);\n\n    // Clear the just-selected flag when user starts typing\n    setJustSelected(false);\n\n    // Reset selectedTime when user types to allow consecutive auto-rounding\n    setSelectedTime(null);\n  };\n\n  // Scroll the selected option into view within the popover\n  const scrollToSelectedOption = useCallback(() => {\n    if (!popoverContentRef.current || selectedOptionIndex < 0) return;\n\n    // Get all option elements and select by index\n    const optionElements =\n      popoverContentRef.current.querySelectorAll('[role=\"option\"]');\n    const targetElement = optionElements[selectedOptionIndex];\n\n    if (targetElement) {\n      targetElement.scrollIntoView({\n        block: \"nearest\",\n        behavior: \"auto\",\n      });\n    }\n  }, [selectedOptionIndex]);\n\n  // Scroll to selected option when selectedOptionIndex changes\n  useEffect(() => {\n    if (isDropdownOpen && selectedOptionIndex >= 0) {\n      scrollToSelectedOption();\n    }\n  }, [selectedOptionIndex, isDropdownOpen, scrollToSelectedOption]);\n\n  // Handle dropdown option selection (Enter key and mouse clicks)\n  const handleOptionSelect = useCallback(\n    (selectedTime: string) => {\n      // Reset typing flag FIRST to ensure MaskedTimeInput will accept the new value\n      if (inputRef.current?.resetTypingFlag) {\n        inputRef.current.resetTypingFlag();\n      }\n\n      // Close dropdown after selection\n      setIsDropdownOpen(false);\n      setSelectedOptionIndex(0);\n\n      // Set flag to prevent auto-reopening on focus\n      setJustSelected(true);\n\n      // Update all state to reflect the selection\n      setCurrentParsedTime(selectedTime);\n      setSelectedTime(selectedTime);\n\n      const changeData = {\n        time: selectedTime,\n        isInputValid: true,\n        isInputEmpty: false,\n      };\n\n      // Notify parent of the change\n      onChange?.(changeData);\n\n      // Update the last onChange call ref to prevent duplicate in blur\n      lastOnChangeCallRef.current = changeData;\n\n      // Focus the input after selection\n      requestAnimationFrame(() => {\n        inputRef.current?.focus();\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [onChange],\n  );\n\n  // Handle keyboard navigation\n  const handleKeyDown = useCallback(\n    (event: React.KeyboardEvent<HTMLInputElement>) => {\n      if (!isDropdownOpen) {\n        return; // Let normal input behavior handle it\n      }\n\n      switch (event.key) {\n        case \"ArrowDown\":\n          event.preventDefault();\n          setSelectedOptionIndex((prev) =>\n            prev < filteredOptions.length - 1 ? prev + 1 : 0,\n          );\n          break;\n        case \"ArrowUp\":\n          event.preventDefault();\n          setSelectedOptionIndex((prev) =>\n            prev > 0 ? prev - 1 : filteredOptions.length - 1,\n          );\n          break;\n        case \"Enter\":\n          event.preventDefault();\n          if (filteredOptions[selectedOptionIndex]) {\n            // Enter: select option, keep dropdown open\n            handleOptionSelect(filteredOptions[selectedOptionIndex]);\n          }\n          break;\n        case \"Tab\":\n          // Set flag to prevent useEffect from reopening dropdown\n          tabJustPressedRef.current = true;\n\n          // Close dropdown and let natural tab behavior happen\n          setIsDropdownOpen(false);\n          setSelectedOptionIndex(0);\n\n          // Clear the flag after blur completes\n          setTimeout(() => {\n            tabJustPressedRef.current = false;\n          }, 50);\n          break;\n      }\n    },\n    [isDropdownOpen, selectedOptionIndex, filteredOptions, handleOptionSelect],\n  );\n\n  const popoverDisabled = disableSuggestions || !popoverSupported;\n\n  const data = {\n    label: childrenToString(label),\n    labelProps,\n    description: childrenToString(description),\n    size,\n    format,\n    step,\n    min,\n    max,\n    autoround,\n    disableSuggestions,\n  };\n  const trackingId = useTrackingId({\n    name: \"TimeField\",\n    data,\n    hasOverride: !!rest[\"data-tracking-id\"],\n  });\n\n  const justTheInput = (\n    <MaskedTimeInput\n      data-tracking-id={trackingId}\n      ref={combinedRef}\n      selectedTime={selectedTime}\n      format={format}\n      placeholder={placeholder}\n      min={min}\n      max={max}\n      onInputChange={handleInputChange}\n      onKeyDown={handleKeyDown}\n      onBlur={handleBlur}\n      onFocus={handleFocus}\n      label={label}\n      labelProps={labelProps}\n      size={size}\n      description={description}\n      error={errorProp}\n      className={popoverDisabled ? className : undefined}\n      {...rest}\n      aria-label={label ? undefined : \"Select a time\"}\n      data-anv=\"time-field\"\n    />\n  );\n\n  if (popoverDisabled) {\n    return justTheInput;\n  }\n\n  return (\n    <Popover\n      open={isDropdownOpen}\n      noPadding\n      disableCaret\n      placement=\"bottom-start\"\n      matchReferenceWidth\n      modal={false}\n      onClickOutside={() => {\n        setIsDropdownOpen(false);\n      }}\n      onClose={() => {\n        setIsDropdownOpen(false);\n      }}\n      fitScreen\n      maxHeight={205}\n    >\n      <Popover.Trigger>\n        {({ ref: iRef }) => {\n          setPopoverTriggerRef(iRef as RefObject<HTMLInputElement>);\n          return justTheInput;\n        }}\n      </Popover.Trigger>\n\n      <Popover.Content\n        ref={popoverContentRef}\n        data-open={isDropdownOpen}\n        data-disabled={disableSuggestions}\n        onMouseDown={() => {\n          // Set flag to indicate dropdown is being clicked (desktop)\n          isDropdownClickingRef.current = true;\n        }}\n        onTouchStart={() => {\n          // Set flag to indicate dropdown is being touched (mobile)\n          isDropdownClickingRef.current = true;\n        }}\n      >\n        {shouldShowOptions && (\n          <Listbox\n            selected={filteredOptions[selectedOptionIndex]}\n            onSelectionChange={(selected: string | undefined) => {\n              if (selected) {\n                handleOptionSelect(selected);\n              } else {\n                // Re-select the same option instead of deselecting (for TimeField, we never want deselection)\n                const currentOption = filteredOptions[selectedOptionIndex];\n                if (currentOption) {\n                  handleOptionSelect(currentOption);\n                }\n              }\n            }}\n            aria-label=\"Time suggestions\"\n          >\n            {filteredOptions.map((option) => (\n              <Listbox.Option key={option} value={option} label={option}>\n                {option}\n              </Listbox.Option>\n            ))}\n          </Listbox>\n        )}\n      </Popover.Content>\n    </Popover>\n  );\n};\n\nTimeField.displayName = \"TimeField\";\n"],"names":["IconAccessTime","timePlaceholderMask","selectedTime"],"mappings":"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"}