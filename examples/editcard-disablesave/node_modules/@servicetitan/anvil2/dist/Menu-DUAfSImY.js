import { jsxs, jsx } from 'react/jsx-runtime';
import * as React from 'react';
import { createContext, forwardRef, useContext, useState, useRef, useEffect, useMemo, useId, useCallback, useLayoutEffect } from 'react';
import { c as cx } from './index-tZvMCc77.js';
import { S as SvgArrowDropDown } from './arrow_drop_down-ChAdBDux.js';
import { B as Button } from './Button-92_FKAyV.js';
import { b as useListItem, c as useFloatingTree, d as useFloatingParentNodeId, F as FloatingTree, e as useFloatingNodeId, D as DialogContext, a as DrawerContext, f as useFloating, o as offset, g as flip, h as shift, i as size, l as limitShift, j as useHover, k as safePolygon, m as useClick, n as useRole, p as useDismiss, q as useListNavigation, r as useTypeahead, v as useInteractions, w as FloatingNode, x as FloatingList, y as FloatingPortal, z as FloatingFocusManager, A as autoUpdate, s as supportsPopover, B as computePosition, C as safeShowPopover, E as safeHidePopover } from './DrawerContext-D4tWTLVf.js';
import { I as Icon } from './Icon-BSuTVNaa.js';
import { c as childrenToString } from './childrenToString-Bz9MqbHb.js';
import { u as useMergeRefs } from './useMergeRefs-Dfmtq9cI.js';
import { useTrackingId } from './useTrackingId.js';
import { g as getActiveElement } from './getActiveElement-BcSyVE7S.js';
import { T as ThemeProviderContext } from './ThemeProviderContext-l52GohYT.js';
import { P as PortalProviderContext } from './PortalProviderContext-B28f2L_g.js';
import { T as ThemeProvider } from './ThemeProvider-Bmsz__5N.js';

import './Menu.css';const SvgArrowDropUp = (props) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M8.71 12.29 11.3 9.7a.996.996 0 0 1 1.41 0l2.59 2.59c.63.63.18 1.71-.71 1.71H9.41c-.89 0-1.33-1.08-.7-1.71z" }));

const MenuContext = createContext(null);

const SvgNavigateNext = (props) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...props }, /* @__PURE__ */ React.createElement("path", { d: "M9.31 6.71a.996.996 0 0 0 0 1.41L13.19 12l-3.88 3.88a.996.996 0 1 0 1.41 1.41l4.59-4.59a.996.996 0 0 0 0-1.41L10.72 6.7c-.38-.38-1.02-.38-1.41.01z" }));

const MenuLegacyContext = createContext({
  getItemProps: () => ({}),
  activeIndex: null,
  isOpen: false
});

const item$1 = "_item_tsacs_4";
const menu = "_menu_tsacs_48";
const scroll = "_scroll_tsacs_59";
const styles$1 = {
	"nested-menu": "_nested-menu_tsacs_3",
	item: item$1,
	menu: menu,
	scroll: scroll,
	"arrow-down": "_arrow-down_tsacs_69",
	"arrow-up": "_arrow-up_tsacs_70",
	"arrow-icon": "_arrow-icon_tsacs_82"};

const MenuLegacyItem = forwardRef(({ label, disabled, icon, className, ...props }, forwardedRef) => {
  const MenuLegacy = useContext(MenuLegacyContext);
  const item = useListItem({
    label: disabled ? null : childrenToString(label)
  });
  const tree = useFloatingTree();
  const isActive = item.index === MenuLegacy.activeIndex;
  const itemCx = cx([styles$1["item"]], className);
  return /* @__PURE__ */ jsxs(
    "button",
    {
      ...props,
      ref: useMergeRefs([item.ref, forwardedRef]),
      type: "button",
      role: "menuitem",
      "data-anv": "menu-item",
      className: itemCx,
      tabIndex: isActive ? 0 : -1,
      disabled,
      ...MenuLegacy.getItemProps({
        onClick(event) {
          props.onClick?.(event);
          tree?.events.emit("click");
        },
        onFocus(event) {
          props.onFocus?.(event);
          MenuLegacy.setHasFocusInside?.(true);
        }
      }),
      children: [
        icon ? /* @__PURE__ */ jsx(Icon, { inherit: true, "aria-hidden": true, svg: icon }) : null,
        label
      ]
    }
  );
});
MenuLegacyItem.displayName = "MenuLegacyItem";

const MenuLegacyComponent = forwardRef(
  ({
    children,
    disableAutoHeight,
    open,
    icon,
    root,
    placement = "bottom-start",
    ...props
  }, forwardedRef) => {
    const [isOpen, setIsOpen] = useState(!!open || false);
    const [hasFocusInside, setHasFocusInside] = useState(false);
    const [activeIndex, setActiveIndex] = useState(null);
    const scrollRef = useRef(null);
    const [scrollTop, setScrollTop] = useState(0);
    const [menuHeight, setMenuLegacyHeight] = useState(null);
    const [arrowStart, setArrowStart] = useState(false);
    const [arrowEnd, setArrowEnd] = useState(false);
    const elementsRef = useRef([]);
    const labelsRef = useRef([]);
    const parent = useContext(MenuLegacyContext);
    const { root: portalRoot } = useContext(PortalProviderContext);
    const tree = useFloatingTree();
    const nodeId = useFloatingNodeId();
    const parentId = useFloatingParentNodeId();
    const item = useListItem();
    const isNested = parentId != null;
    const { theme, mode = "light" } = useContext(ThemeProviderContext);
    const dialogContext = useContext(DialogContext);
    const drawerContext = useContext(DrawerContext);
    const fallbackArr = () => {
      if (!isNested) {
        if (placement.startsWith("top")) {
          return disableAutoHeight ? placement : ["top-start", "top-end", "bottom-start", "bottom-end"];
        }
        return disableAutoHeight ? placement : ["bottom-start", "bottom-end", "top-start", "top-end"];
      }
      return parent.disableAutoHeight ? ["right-start"] : ["right-start", "right-end", "left-start", "left-end"];
    };
    const handleIsOpenChange = (internalOpen) => {
      if (typeof open === "boolean") {
        setIsOpen(open);
        return;
      }
      setIsOpen(internalOpen);
    };
    const { floatingStyles, refs, context } = useFloating({
      nodeId,
      open: isOpen,
      onOpenChange: handleIsOpenChange,
      placement: isNested ? "right-start" : placement,
      middleware: [
        offset({
          mainAxis: isNested ? 0 : 4,
          alignmentAxis: isNested ? -4 : 0
        }),
        flip({
          fallbackStrategy: "bestFit",
          fallbackPlacements: fallbackArr()
        }),
        shift({
          mainAxis: !parent.disableAutoHeight,
          crossAxis: false,
          limiter: limitShift({
            mainAxis: !parent.disableAutoHeight
          })
        }),
        size({
          padding: 8,
          apply({ availableWidth, availableHeight, elements }) {
            if (disableAutoHeight ?? parent.disableAutoHeight) return;
            setMenuLegacyHeight(availableHeight);
            Object.assign(elements.floating.style, {
              maxWidth: `${availableWidth}px`,
              maxHeight: `${availableHeight}px`
            });
          }
        })
      ],
      whileElementsMounted: autoUpdate
    });
    const [hoverEnabled, setHoverEnabled] = useState(false);
    const hover = useHover(context, {
      enabled: hoverEnabled,
      delay: { open: 75 },
      handleClose: safePolygon({ blockPointerEvents: true })
    });
    const click = useClick(context, {
      event: "mousedown",
      toggle: !isNested,
      ignoreMouse: isNested
    });
    const role = useRole(context, { role: "menu" });
    const dismiss = useDismiss(context, { bubbles: true });
    const listNavigation = useListNavigation(context, {
      listRef: elementsRef,
      activeIndex,
      nested: isNested,
      onNavigate: setActiveIndex
    });
    const typeahead = useTypeahead(context, {
      listRef: labelsRef,
      onMatch: isOpen ? setActiveIndex : void 0,
      activeIndex
    });
    const { getReferenceProps, getFloatingProps, getItemProps } = useInteractions([hover, click, role, dismiss, listNavigation, typeahead]);
    useEffect(() => {
      if (!tree) return;
      function handleTreeClick() {
        setIsOpen(!!open || false);
      }
      function onSubMenuLegacyOpen(event) {
        if (event.nodeId === nodeId || event.parentId !== parentId) {
          return;
        }
        setIsOpen(!!open || false);
      }
      tree.events.on("click", handleTreeClick);
      tree.events.on("menuopen", onSubMenuLegacyOpen);
      return () => {
        tree.events.off("click", handleTreeClick);
        tree.events.off("menuopen", onSubMenuLegacyOpen);
      };
    }, [tree, nodeId, parentId]);
    useEffect(() => {
      if (disableAutoHeight ?? parent.disableAutoHeight) return;
      if (!isOpen) {
        setMenuLegacyHeight(null);
        return;
      }
      setTimeout(() => {
        if (!scrollRef.current || !refs.floating.current) return;
        setMenuLegacyHeight(refs.floating.current.clientHeight);
        const isOverflow = scrollRef.current.scrollHeight > refs.floating.current.clientHeight;
        if (!isOverflow) return;
        const showTop = scrollRef.current.scrollTop > 0;
        const showBottom = scrollRef.current.scrollHeight - refs.floating.current.clientHeight - scrollTop - 16 > 0;
        setArrowStart(showTop);
        setArrowEnd(showBottom);
      }, 0);
    }, [
      disableAutoHeight,
      isOpen,
      parent.disableAutoHeight,
      refs.floating,
      scrollTop
    ]);
    useEffect(() => {
      if (!isOpen || !tree) return;
      tree.events.emit("menuopen", { parentId, nodeId });
    }, [tree, isOpen, nodeId, parentId]);
    const menuComponentCX = cx({
      [styles$1["nested-menu"]]: isNested,
      [styles$1["item"]]: !isNested
    });
    const menuRefs = useMergeRefs([refs.setReference, item.ref, forwardedRef]);
    const triggerProps = {
      "data-open": isOpen,
      "data-focus-inside": hasFocusInside,
      ref: menuRefs,
      ...getReferenceProps(
        parent.getItemProps({
          ...props,
          // This is to allow any type of element to be used as a custom trigger element
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onFocus(event) {
            props.onFocus?.(event);
            setHasFocusInside(false);
            parent.setHasFocusInside?.(true);
          }
          // This is to allow any type of element to be used as a custom trigger element
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        })
      )
    };
    const value = useMemo(
      () => ({
        activeIndex,
        setActiveIndex,
        getItemProps,
        setHasFocusInside,
        isOpen,
        disableAutoHeight: disableAutoHeight ?? parent.disableAutoHeight
      }),
      [
        activeIndex,
        disableAutoHeight,
        getItemProps,
        isOpen,
        parent.disableAutoHeight
      ]
    );
    return /* @__PURE__ */ jsxs(FloatingNode, { id: nodeId, children: [
      isNested ? /* @__PURE__ */ jsxs(
        "button",
        {
          ref: menuRefs,
          tabIndex: parent.activeIndex === item.index ? 0 : -1,
          role: "menuitem",
          "data-anv": "menu-item",
          "data-open": isOpen ? "" : void 0,
          "data-nested": "",
          "data-focus-inside": hasFocusInside ? "" : void 0,
          className: menuComponentCX,
          ...getReferenceProps(
            parent.getItemProps({
              ...props,
              onFocus(event) {
                props.onFocus?.(event);
                setHasFocusInside(false);
                parent.setHasFocusInside?.(true);
              },
              onMouseEnter: () => setHoverEnabled(true)
            })
          ),
          children: [
            icon ? /* @__PURE__ */ jsx(Icon, { inherit: true, "aria-hidden": true, svg: icon }) : null,
            "label" in props && props.label,
            /* @__PURE__ */ jsx("div", { style: { flexGrow: 1 } }),
            /* @__PURE__ */ jsx(Icon, { "aria-hidden": true, svg: SvgNavigateNext })
          ]
        }
      ) : "trigger" in props ? props.trigger?.(triggerProps) : /* @__PURE__ */ jsx(
        Button,
        {
          ...props,
          ...triggerProps,
          ...getReferenceProps({
            onFocus: (event) => props.onFocus?.(event)
          }),
          icon,
          "data-anv": "menu",
          children: "label" in props && props.label
        }
      ),
      /* @__PURE__ */ jsx(MenuLegacyContext.Provider, { value, children: /* @__PURE__ */ jsx(FloatingList, { elementsRef, labelsRef, children: isOpen && (dialogContext == null || dialogContext?.ref?.current != null) && /* @__PURE__ */ jsx(
        FloatingPortal,
        {
          root: root ?? dialogContext?.ref?.current ?? drawerContext?.ref?.current ?? portalRoot,
          children: /* @__PURE__ */ jsx(
            FloatingFocusManager,
            {
              context,
              modal: false,
              initialFocus: isNested ? -1 : 0,
              returnFocus: !isNested,
              children: /* @__PURE__ */ jsx(ThemeProvider, { theme, mode, children: /* @__PURE__ */ jsxs(
                "div",
                {
                  ref: refs.setFloating,
                  className: styles$1["menu"],
                  style: floatingStyles,
                  ...getFloatingProps({
                    onMouseEnter: () => {
                      setHoverEnabled(false);
                    },
                    onKeyDown: (e) => {
                      if (e.code === "ArrowLeft" || e.code === "ArrowRight") {
                        e.stopPropagation();
                      }
                    }
                  }),
                  children: [
                    arrowStart && /* @__PURE__ */ jsx("div", { className: styles$1["arrow-up"], "aria-hidden": true, children: /* @__PURE__ */ jsx(
                      Icon,
                      {
                        svg: SvgArrowDropUp,
                        size: "xlarge",
                        className: styles$1["arrow-icon"]
                      }
                    ) }),
                    /* @__PURE__ */ jsx(
                      "div",
                      {
                        ref: scrollRef,
                        className: styles$1["scroll"],
                        style: {
                          position: "relative",
                          maxHeight: menuHeight ?? "inherit"
                        },
                        onScroll: (e) => setScrollTop(e.currentTarget.scrollTop),
                        children
                      }
                    ),
                    arrowEnd && /* @__PURE__ */ jsx("div", { className: styles$1["arrow-down"], "aria-hidden": true, children: /* @__PURE__ */ jsx(
                      Icon,
                      {
                        svg: SvgArrowDropDown,
                        size: "xlarge",
                        className: styles$1["arrow-icon"]
                      }
                    ) })
                  ]
                }
              ) })
            }
          )
        }
      ) }) })
    ] });
  }
);
MenuLegacyComponent.displayName = "MenuLegacyComponent";
const MenuLegacyElement = forwardRef(
  (props, ref) => {
    const parentId = useFloatingParentNodeId();
    if (parentId === null) {
      return /* @__PURE__ */ jsx(FloatingTree, { children: /* @__PURE__ */ jsx(MenuLegacyComponent, { ...props, ref }) });
    }
    return /* @__PURE__ */ jsx(MenuLegacyComponent, { ...props, ref });
  }
);
MenuLegacyElement.displayName = "MenuLegacy";
const MenuLegacy = Object.assign(MenuLegacyElement, {
  Item: MenuLegacyItem
});

const item = "_item_w0dno_2";
const content = "_content_w0dno_15";
const scroller = "_scroller_w0dno_63";
const styles = {
	item: item,
	content: content,
	scroller: scroller,
	"arrow-down": "_arrow-down_w0dno_79",
	"arrow-up": "_arrow-up_w0dno_80",
	"arrow-icon": "_arrow-icon_w0dno_92"};

const MenuItem = forwardRef((props, ref) => {
  const {
    label,
    disabled,
    icon,
    className,
    onClick,
    onMouseEnter,
    id: idProp,
    ...rest
  } = props;
  const menuContext = useContext(MenuContext);
  const uid = useId();
  const buttonRef = useRef(null);
  const combinedRef = useMergeRefs([buttonRef, ref]);
  const [tabIndex, setTabIndex] = useState(-1);
  const itemCx = cx([styles["item"]], className);
  const onClickHandler = (e) => {
    if (disabled) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    onClick?.(e);
    menuContext?.closeRootMenu();
  };
  const onMouseEnterHandler = (e) => {
    onMouseEnter?.(e);
    buttonRef.current?.focus();
  };
  const onFocusHandler = () => {
    setTabIndex(0);
  };
  const onBlurHandler = () => {
    setTabIndex(-1);
  };
  const data = {
    label: childrenToString(props.label)
  };
  const trackingId = useTrackingId({
    name: "MenuItem",
    data,
    hasOverride: !!props["data-tracking-id"]
  });
  if (!supportsPopover())
    return /* @__PURE__ */ jsx(MenuLegacyItem, { "data-tracking-id": trackingId, ...props, ref });
  return /* @__PURE__ */ jsxs(
    "button",
    {
      "data-tracking-id": trackingId,
      ...rest,
      ref: combinedRef,
      type: "button",
      role: "menuitem",
      "data-anv": "menu-item",
      id: idProp ?? `menuitem-${uid.replace(/:/g, "")}`,
      className: itemCx,
      tabIndex,
      "aria-disabled": disabled,
      onClick: onClickHandler,
      onMouseEnter: onMouseEnterHandler,
      onFocus: onFocusHandler,
      onBlur: onBlurHandler,
      children: [
        icon ? /* @__PURE__ */ jsx(Icon, { inherit: true, "aria-hidden": true, svg: icon }) : null,
        label
      ]
    }
  );
});
MenuItem.displayName = "MenuItem";

const MenuNested = (props) => {
  const { children, open, defaultOpen = false, label, className, icon } = props;
  const uid = useId();
  const [tabIndex, setTabIndex] = useState(-1);
  const [openState, setOpenState] = useState(open ?? defaultOpen);
  const [scrollTop, setScrollTop] = useState(0);
  const [menuHeight, setMenuHeight] = useState(null);
  const [arrowStart, setArrowStart] = useState(false);
  const [arrowEnd, setArrowEnd] = useState(false);
  const invokerRef = useRef(null);
  const menuRef = useRef(null);
  const childrenRef = useRef(null);
  const containerRef = useRef(null);
  const [focusItems, setFocusItems] = useState();
  const menuContext = useContext(MenuContext);
  const fallbackArr = useCallback(() => {
    return menuContext?.disableAutoHeight ? ["right-start"] : ["right-start", "right-end", "left-start", "left-end"];
  }, [menuContext?.disableAutoHeight]);
  const updatePosition = useCallback(() => {
    if (!invokerRef.current || !menuRef.current) return;
    const timeoutId = setTimeout(() => {
      if (!invokerRef.current || !menuRef.current) return;
      computePosition(invokerRef.current, menuRef.current, {
        placement: "right-start",
        middleware: [
          offset({
            mainAxis: 0,
            alignmentAxis: -4
          }),
          flip({
            fallbackStrategy: "bestFit",
            fallbackPlacements: fallbackArr()
          }),
          shift({
            mainAxis: !menuContext?.disableAutoHeight,
            crossAxis: false,
            limiter: limitShift({
              mainAxis: !menuContext?.disableAutoHeight
            })
          }),
          size({
            padding: 8,
            apply({ availableWidth, availableHeight, elements }) {
              if (menuContext?.disableAutoHeight) return;
              const newHeight = availableHeight - 16;
              if (Math.abs((menuHeight ?? 0) - newHeight) > 1) {
                setMenuHeight(newHeight);
                Object.assign(elements.floating.style, {
                  maxWidth: `${availableWidth - 16}px`,
                  maxHeight: `${newHeight}px`
                });
              }
            }
          })
        ]
      }).then(({ x, y }) => {
        if (!menuRef.current) return;
        Object.assign(menuRef.current.style, {
          left: `${x}px`,
          top: `${y + 8}px`
        });
      });
    }, 50);
    return () => clearTimeout(timeoutId);
  }, [fallbackArr, menuContext?.disableAutoHeight, menuHeight]);
  const menuReference = useRef(null);
  useLayoutEffect(() => {
    if (!openState) {
      setMenuHeight(null);
      setScrollTop(0);
      return;
    }
    if (!menuRef.current) return;
    menuReference.current = menuRef.current;
    let resizeTimeout = null;
    ({
      height: menuReference.current.clientHeight,
      scrollHeight: childrenRef.current?.scrollHeight ?? 0
    });
    const updateArrows = (height, scrollHeight) => {
      if (!childrenRef.current) return;
      const isOverflow = scrollHeight > height;
      setArrowStart(isOverflow && childrenRef.current.scrollTop > 0);
      setArrowEnd(isOverflow && scrollHeight - height - scrollTop - 16 > 0);
    };
    const observer = new ResizeObserver(() => {
      if (!childrenRef.current || !menuReference.current) return;
      if (resizeTimeout) {
        window.clearTimeout(resizeTimeout);
      }
      resizeTimeout = window.setTimeout(() => {
        const newHeight = menuReference.current?.clientHeight ?? 0;
        const newScrollHeight = childrenRef.current?.scrollHeight ?? 0;
        if (!newHeight) return;
        updateArrows(newHeight, newScrollHeight);
      }, 100);
    });
    if (menuReference.current) {
      observer.observe(menuReference.current);
    }
    return () => {
      if (resizeTimeout) {
        window.clearTimeout(resizeTimeout);
      }
      if (menuReference.current) {
        observer.unobserve(menuReference.current);
      }
      observer.disconnect();
    };
  }, [openState, scrollTop]);
  useLayoutEffect(() => {
    if (!menuRef.current || !invokerRef.current) return;
    const cleanup = autoUpdate(invokerRef.current, menuRef.current, () => {
      updatePosition();
    });
    return () => {
      cleanup();
    };
  }, [updatePosition]);
  const popoverHoverTriggered = useRef();
  const openMenu = useCallback(async () => {
    popoverHoverTriggered.current = true;
    await new Promise((resolve) => setTimeout(resolve, 100));
    if (!popoverHoverTriggered.current || !menuRef.current || !childrenRef.current)
      return;
    menuRef.current.style.opacity = "0";
    safeShowPopover(menuRef.current);
    if (!invokerRef.current || !menuRef.current) return;
    await computePosition(invokerRef.current, menuRef.current, {
      placement: "right-start",
      middleware: [
        offset({
          mainAxis: 0,
          alignmentAxis: -4
        }),
        flip({
          fallbackStrategy: "bestFit",
          fallbackPlacements: fallbackArr()
        }),
        shift({
          mainAxis: !menuContext?.disableAutoHeight,
          crossAxis: false,
          limiter: limitShift({
            mainAxis: !menuContext?.disableAutoHeight
          })
        })
      ]
    }).then(({ x, y }) => {
      if (!menuRef.current) return;
      Object.assign(menuRef.current.style, {
        left: `${x}px`,
        top: `${y + 8}px`
      });
    });
    setOpenState(true);
    const focusables = Array.from(
      childrenRef.current.querySelectorAll(
        `#scroller-${uid.replace(/:/g, "")} > button, #scroller-${uid.replace(/:/g, "")} > div[data-nested="true"] > button, #scroller-${uid.replace(/:/g, "")} > a[href]`
      )
    );
    setFocusItems(focusables);
    requestAnimationFrame(() => {
      if (!menuRef.current) return;
      menuRef.current.style.opacity = "1";
    });
  }, [uid, fallbackArr, menuContext?.disableAutoHeight]);
  const closeMenu = useCallback(async (fn) => {
    popoverHoverTriggered.current = false;
    await new Promise((resolve) => setTimeout(resolve, 100));
    if (popoverHoverTriggered.current || !menuRef.current) return;
    fn?.();
    safeHidePopover(menuRef.current);
    setOpenState(false);
  }, []);
  const isControlled = typeof open !== "undefined";
  const initialRender = useRef(true);
  useEffect(() => {
    if (!isControlled) return;
    if (initialRender.current === true) {
      if (open && menuRef.current) {
        openMenu();
      }
      initialRender.current = false;
      return;
    }
    setOpenState(open);
    if (open) {
      openMenu();
    } else {
      closeMenu();
    }
  }, [closeMenu, isControlled, open, openMenu]);
  useEffect(() => {
    if (!containerRef.current) return;
    const nestedContainer = containerRef.current;
    nestedContainer.addEventListener("focusin", (_e) => {
      openMenu();
    });
    nestedContainer.addEventListener("focusout", () => closeMenu());
    return () => {
      nestedContainer.removeEventListener("focusin", () => openMenu());
      nestedContainer.removeEventListener("focusout", () => closeMenu());
    };
  }, [closeMenu, openMenu]);
  const onKeyDownHandler = (e) => {
    if (!openState || !childrenRef.current) return;
    const currentActiveIndex = focusItems?.findIndex(
      (item) => item.id === getActiveElement(document)?.id
    );
    const firstItem = focusItems?.[0];
    const lastItem = focusItems?.[focusItems.length - 1];
    if (e.code === "Escape") {
      menuContext?.closeRootMenu();
    }
    if (e.code === "ArrowLeft") {
      e.stopPropagation();
      e.preventDefault();
      invokerRef.current?.focus();
      closeMenu();
    }
    if (e.code === "ArrowDown") {
      e.stopPropagation();
      if (currentActiveIndex === (focusItems?.length ?? 0) - 1) {
        firstItem.focus();
        return;
      }
      const nextItem = focusItems?.[(currentActiveIndex ?? 0) + 1];
      nextItem.focus();
      return;
    }
    if (e.code === "ArrowUp") {
      e.stopPropagation();
      e.preventDefault();
      if (currentActiveIndex === 0) {
        lastItem.focus();
        return;
      }
      const prevItem = focusItems?.[(currentActiveIndex ?? 0) - 1];
      prevItem.focus();
      return;
    }
  };
  const onFocusHandler = () => {
    setTabIndex(0);
  };
  const onBlurHandler = () => {
    setTabIndex(-1);
  };
  const MenuButtonOnKeyDownHandler = (e) => {
    if (e.code === "ArrowRight") {
      e.stopPropagation();
      e.preventDefault();
      openMenu();
      const firstItem = menuRef.current?.querySelectorAll(
        `#scroller-${uid.replace(/:/g, "")} > button, #scroller-${uid.replace(/:/g, "")} > a[href]`
      )[0];
      firstItem.focus();
    }
  };
  const MenuButtonOnClick = () => {
    if (isControlled) return;
    openMenu();
  };
  const itemCx = cx([styles["item"]], className);
  return /* @__PURE__ */ jsxs("div", { ref: containerRef, "data-nested": "true", children: [
    /* @__PURE__ */ jsxs(
      "button",
      {
        role: "menuitem",
        "data-anv": "menu-item",
        "data-state": openState ? "open" : "close",
        ref: invokerRef,
        id: `menuitem-${uid.replace(/:/g, "")}`,
        "aria-expanded": openState,
        onMouseEnter: (e) => {
          e.currentTarget.focus();
        },
        onKeyDown: MenuButtonOnKeyDownHandler,
        onFocus: onFocusHandler,
        onBlur: onBlurHandler,
        onClick: MenuButtonOnClick,
        "aria-haspopup": true,
        "aria-controls": `menu-${uid.replace(/:/g, "")}`,
        className: itemCx,
        tabIndex,
        children: [
          icon ? /* @__PURE__ */ jsx(Icon, { inherit: true, "aria-hidden": true, svg: icon }) : null,
          label,
          /* @__PURE__ */ jsx("div", { style: { flexGrow: 1 } }),
          /* @__PURE__ */ jsx(Icon, { "aria-hidden": true, svg: SvgNavigateNext })
        ]
      }
    ),
    /* @__PURE__ */ jsxs(
      "div",
      {
        popover: "auto",
        id: `menu-${uid.replace(/:/g, "")}`,
        "data-anv": "menu-content",
        className: styles.content,
        ref: menuRef,
        role: "presentation",
        onKeyDown: onKeyDownHandler,
        children: [
          arrowStart && /* @__PURE__ */ jsx("div", { className: styles["arrow-up"], "aria-hidden": true, children: /* @__PURE__ */ jsx(Icon, { svg: SvgArrowDropUp, size: "xlarge", className: styles["arrow-icon"] }) }),
          /* @__PURE__ */ jsx(
            "div",
            {
              className: styles.scroller,
              tabIndex: -1,
              ref: childrenRef,
              style: {
                position: "relative",
                maxHeight: menuHeight ?? "inherit"
              },
              onScroll: (e) => setScrollTop(e.currentTarget.scrollTop),
              role: "menu",
              id: `scroller-${uid.replace(/:/g, "")}`,
              children
            }
          ),
          arrowEnd && /* @__PURE__ */ jsx("div", { className: styles["arrow-down"], "aria-hidden": true, children: /* @__PURE__ */ jsx(Icon, { svg: SvgArrowDropDown, size: "xlarge", className: styles["arrow-icon"] }) })
        ]
      }
    )
  ] });
};

const MenuElement = forwardRef(
  (props, ref) => {
    const {
      children,
      placement = "bottom-start",
      open,
      defaultOpen = false,
      disableAutoHeight,
      label,
      onOutsidePress,
      trigger,
      root,
      contentClassName,
      maxHeight,
      ...rest
    } = props;
    const uid = useId();
    const [openState, setOpenState] = useState(open ?? defaultOpen);
    const [scrollTop, setScrollTop] = useState(0);
    const [menuHeight, setMenuHeight] = useState(null);
    const [arrowStart, setArrowStart] = useState(false);
    const [arrowEnd, setArrowEnd] = useState(false);
    const invokerRef = useRef(null);
    const menuRef = useRef(null);
    const childrenRef = useRef(null);
    const [focusItems, setFocusItems] = useState();
    const dialogContext = useContext(DialogContext);
    const menuContext = useContext(MenuContext);
    const fallbackArr = useCallback(() => {
      if (placement.startsWith("top")) {
        return disableAutoHeight ? [placement] : ["top-start", "top-end", "bottom-start", "bottom-end"];
      }
      return disableAutoHeight ? [placement] : ["bottom-start", "bottom-end", "top-start", "top-end"];
    }, [disableAutoHeight, placement]);
    const updatePosition = useCallback(() => {
      if (!invokerRef.current || !menuRef.current) return;
      const timeoutId = setTimeout(() => {
        if (!invokerRef.current || !menuRef.current) return;
        computePosition(invokerRef.current, menuRef.current, {
          placement,
          middleware: [
            offset({
              mainAxis: 5,
              alignmentAxis: 0
            }),
            flip({
              fallbackStrategy: "bestFit",
              fallbackPlacements: fallbackArr(),
              padding: 50
              // Setting to 50px as it is the size of menu with 1 item in it
            }),
            shift({
              mainAxis: !menuContext?.disableAutoHeight,
              crossAxis: false,
              limiter: limitShift({
                mainAxis: !menuContext?.disableAutoHeight
              })
            }),
            size({
              padding: 8,
              apply({ availableWidth, availableHeight, elements }) {
                if (disableAutoHeight ?? menuContext?.disableAutoHeight) return;
                const newHeight = availableHeight - 16;
                if (Math.abs((menuHeight ?? 0) - newHeight) > 1) {
                  setMenuHeight(newHeight);
                  Object.assign(elements.floating.style, {
                    maxWidth: `${availableWidth - 16}px`,
                    maxHeight: maxHeight ? `${Math.min(newHeight, typeof maxHeight === "number" ? maxHeight : parseInt(maxHeight.toString()))}px` : `${newHeight}px`
                  });
                }
              }
            })
          ]
        }).then(({ x, y }) => {
          if (!menuRef.current) return;
          Object.assign(menuRef.current.style, {
            left: `${x}px`,
            top: `${y}px`
          });
          menuRef.current.dataset.positioned = "true";
        });
      }, 50);
      return () => clearTimeout(timeoutId);
    }, [
      placement,
      fallbackArr,
      menuContext?.disableAutoHeight,
      disableAutoHeight,
      menuHeight,
      maxHeight
    ]);
    const menuReference = useRef(null);
    useLayoutEffect(() => {
      if (!openState) {
        setMenuHeight(null);
        setScrollTop(0);
        return;
      }
      if (!menuRef.current) return;
      menuReference.current = menuRef.current;
      let resizeTimeout = null;
      ({
        height: menuReference.current.clientHeight,
        scrollHeight: childrenRef.current?.scrollHeight ?? 0
      });
      const updateArrows = (height, scrollHeight) => {
        if (!childrenRef.current) return;
        const isOverflow = scrollHeight > height;
        setArrowStart(isOverflow && childrenRef.current.scrollTop > 0);
        setArrowEnd(isOverflow && scrollHeight - height - scrollTop - 16 > 0);
      };
      const observer = new ResizeObserver(() => {
        if (!childrenRef.current || !menuReference.current) return;
        if (resizeTimeout) {
          window.clearTimeout(resizeTimeout);
        }
        resizeTimeout = window.setTimeout(() => {
          const newHeight = menuReference.current?.clientHeight ?? 0;
          const newScrollHeight = childrenRef.current?.scrollHeight ?? 0;
          if (!newHeight) return;
          updateArrows(newHeight, newScrollHeight);
        }, 150);
      });
      if (menuReference.current) {
        observer.observe(menuReference.current);
      }
      return () => {
        if (resizeTimeout) {
          window.clearTimeout(resizeTimeout);
        }
        if (menuReference.current) {
          observer.unobserve(menuReference.current);
        }
        observer.disconnect();
      };
    }, [openState, scrollTop]);
    useLayoutEffect(() => {
      if (!menuRef.current || !invokerRef.current) return;
      const cleanup = autoUpdate(invokerRef.current, menuRef.current, () => {
        updatePosition();
      });
      return () => {
        cleanup();
      };
    }, [updatePosition]);
    const openMenu = useCallback(async () => {
      if (!menuRef.current || !childrenRef.current) return;
      safeShowPopover(menuRef.current);
      if (!invokerRef.current || !menuRef.current) return;
      await computePosition(invokerRef.current, menuRef.current, {
        placement,
        middleware: [
          offset({
            mainAxis: 5,
            alignmentAxis: 0
          }),
          flip({
            fallbackStrategy: "bestFit",
            fallbackPlacements: fallbackArr(),
            padding: 50
            // Setting to 50px as it is the size of menu with 1 item in it
          }),
          shift({
            mainAxis: !menuContext?.disableAutoHeight,
            crossAxis: false,
            limiter: limitShift({
              mainAxis: !menuContext?.disableAutoHeight
            })
          })
        ]
      }).then(({ x, y }) => {
        if (!menuRef.current) return;
        Object.assign(menuRef.current.style, {
          left: `${x}px`,
          top: `${y}px`
        });
        menuRef.current.dataset.positioned = "true";
      });
      setOpenState(true);
      requestAnimationFrame(() => {
        if (!childrenRef.current) return;
        const focusables = Array.from(
          childrenRef.current.querySelectorAll(
            `#scroller-${uid.replace(/:/g, "")} > button, #scroller-${uid.replace(/:/g, "")} > div[data-nested="true"] > button, #scroller-${uid.replace(/:/g, "")} > a[href]`
          )
        );
        setFocusItems(focusables);
      });
      dialogContext?.setHasOpenPopover?.(true);
    }, [
      dialogContext,
      uid,
      placement,
      fallbackArr,
      menuContext?.disableAutoHeight
    ]);
    const closeMenu = useCallback(
      async (fn) => {
        if (!menuRef.current || !openState) return;
        fn?.();
        setOpenState(false);
        safeHidePopover(menuRef.current);
        dialogContext?.setHasOpenPopover?.(false);
        invokerRef.current?.focus();
      },
      [openState, dialogContext]
    );
    const isControlled = typeof open !== "undefined";
    const initialRender = useRef(true);
    useEffect(() => {
      if (!isControlled) return;
      if (initialRender.current === true) {
        if (open && menuRef.current) {
          openMenu();
        }
        initialRender.current = false;
        return;
      }
      if (open) {
        openMenu();
      } else {
        closeMenu();
      }
    }, [closeMenu, isControlled, open, openMenu, dialogContext]);
    useEffect(() => {
      if (typeof document === "undefined") return;
      let isClosable = false;
      const onMouseDownHandler = (e) => {
        if (!invokerRef.current || !menuRef.current) return;
        const isInvoker = e.composedPath().includes(invokerRef.current);
        const isPopover = e.composedPath().includes(menuRef.current);
        if (!isInvoker && !isPopover && openState) {
          onOutsidePress?.(e);
          isClosable = true;
        }
      };
      const onMouseUpHandler = (e) => {
        if (!invokerRef.current || !menuRef.current) return;
        const isInvoker = e.composedPath().includes(invokerRef.current);
        const isPopover = e.composedPath().includes(menuRef.current);
        if (!isInvoker && !isPopover && openState) {
          if (isControlled || !isClosable || !openState) return;
          closeMenu();
        }
      };
      document.addEventListener("mousedown", onMouseDownHandler);
      document.addEventListener("mouseup", onMouseUpHandler);
      return () => {
        document.removeEventListener("mousedown", onMouseDownHandler);
        document.removeEventListener("mouseup", onMouseUpHandler);
      };
    }, [isControlled, openState, onOutsidePress, closeMenu]);
    const onKeyDownHandler = (e) => {
      if (!openState || !childrenRef.current || menuContext) return;
      if (e.code === "Escape") {
        e.stopPropagation();
        e.preventDefault();
        closeMenu();
      }
      const currentActiveIndex = focusItems?.findIndex(
        (item) => item.id === getActiveElement(document)?.id
      );
      const firstItem = focusItems?.[0];
      const lastItem = focusItems?.[focusItems.length - 1];
      if (e.code === "ArrowDown") {
        e.stopPropagation();
        e.preventDefault();
        if (currentActiveIndex === (focusItems?.length ?? 0) - 1) {
          firstItem.focus();
          return;
        }
        const nextItem = focusItems?.[(currentActiveIndex ?? 0) + 1];
        nextItem.focus();
        return;
      }
      if (e.code === "ArrowUp") {
        e.stopPropagation();
        e.preventDefault();
        if (currentActiveIndex === 0) {
          lastItem.focus();
          return;
        }
        const prevItem = focusItems?.[(currentActiveIndex ?? 0) - 1];
        prevItem.focus();
        return;
      }
    };
    const value = useMemo(() => {
      return {
        disableAutoHeight,
        closeRootMenu: menuContext?.closeRootMenu ?? closeMenu
      };
    }, [disableAutoHeight, menuContext, closeMenu]);
    const MenuButtonOnKeyDownHandler = (e) => {
      if (e.code === "ArrowDown") {
        focusItems?.[0].focus();
        e.stopPropagation();
        e.preventDefault();
      }
    };
    const MenuButtonOnClick = () => {
      if (isControlled) return;
      if (openState) {
        closeMenu();
        return;
      }
      openMenu();
    };
    const data = {
      label: childrenToString(props.label)
    };
    const trackingId = useTrackingId({
      name: "Menu",
      data,
      hasOverride: !!props["data-tracking-id"]
    });
    if (!supportsPopover())
      return /* @__PURE__ */ jsx(
        MenuLegacy,
        {
          "data-tracking-id": trackingId,
          ...props,
          ref
        }
      );
    if (menuContext) {
      return /* @__PURE__ */ jsx(MenuContext.Provider, { value, children: /* @__PURE__ */ jsx(
        MenuNested,
        {
          "data-tracking-id": trackingId,
          open,
          defaultOpen,
          className: props.className,
          icon: props.icon,
          label,
          children
        }
      ) });
    }
    return /* @__PURE__ */ jsxs(MenuContext.Provider, { value, children: [
      trigger ? trigger({
        ref: invokerRef,
        onClick: () => MenuButtonOnClick(),
        onKeyDown: MenuButtonOnKeyDownHandler,
        "aria-haspopup": true,
        "aria-controls": `menu-${uid.replace(/:/g, "")}`,
        "aria-expanded": openState,
        "data-state": openState ? "open" : "close"
      }) : /* @__PURE__ */ jsx(
        Button,
        {
          ref: invokerRef,
          onClick: MenuButtonOnClick,
          onKeyDown: MenuButtonOnKeyDownHandler,
          "aria-haspopup": true,
          "aria-controls": `menu-${uid.replace(/:/g, "")}`,
          "data-state": openState ? "open" : "close",
          "aria-expanded": openState,
          ...rest,
          children: label
        }
      ),
      /* @__PURE__ */ jsxs(
        "div",
        {
          popover: "manual",
          id: `menu-${uid.replace(/:/g, "")}`,
          "data-anv": "menu-content",
          className: cx(styles.content, contentClassName),
          onKeyDown: onKeyDownHandler,
          ref: menuRef,
          role: "presentation",
          children: [
            arrowStart && /* @__PURE__ */ jsx("div", { className: styles["arrow-up"], "aria-hidden": true, children: /* @__PURE__ */ jsx(Icon, { svg: SvgArrowDropUp, size: "xlarge", className: styles["arrow-icon"] }) }),
            /* @__PURE__ */ jsx(
              "div",
              {
                className: styles.scroller,
                tabIndex: -1,
                ref: childrenRef,
                style: {
                  position: "relative",
                  maxHeight: maxHeight ? `${Math.min(menuHeight ?? Infinity, typeof maxHeight === "number" ? maxHeight : parseInt(maxHeight.toString()))}px` : menuHeight ?? "inherit"
                },
                onScroll: (e) => setScrollTop(e.currentTarget.scrollTop),
                role: "menu",
                id: `scroller-${uid.replace(/:/g, "")}`,
                children
              }
            ),
            arrowEnd && /* @__PURE__ */ jsx("div", { className: styles["arrow-down"], "aria-hidden": true, children: /* @__PURE__ */ jsx(Icon, { svg: SvgArrowDropDown, size: "xlarge", className: styles["arrow-icon"] }) })
          ]
        }
      )
    ] });
  }
);
MenuElement.displayName = "Menu";
const Menu = Object.assign(MenuElement, {
  /**
   * MenuItem component for individual menu options.
   *
   * Features:
   * - Supports icons and labels
   * - Keyboard navigation support
   * - Disabled state handling
   * - Automatic menu closing on selection
   * - Fully accessible with proper ARIA attributes
   * - Focus management and tab index handling
   * - Click and mouse enter event handling
   *
   * @example
   * <Menu.Item
   *   label="Edit Profile"
   *   icon={EditIcon}
   *   onClick={() => console.log('Edit profile clicked')}
   * />
   */
  Item: MenuItem
});

export { Menu as M, MenuItem as a };
//# sourceMappingURL=Menu-DUAfSImY.js.map
