{"version":3,"file":"makeZeroShortcutPreprocessor-CxsiGTRW.js","sources":["../src/components/DateFieldSingle/internal/maskito/makeZeroShortcutPreprocessor.ts"],"sourcesContent":["import { MaskitoPreprocessor } from \"@maskito/core\";\nimport { SelectionRange } from \"@maskito/core/src/lib/types\";\n\n/**\n * This is a custom-written preprocessor to handle the zero shortcut on slash.\n * e.g: 1/ -> 01/ and 01/1/ -> 01/01/\n *\n * @param templateString - A string representing the mask. e.g. \"dd/mm/yyyy\" or \"__/__/____\"\n * @param separator - The separator to use for segments of the date. Must match the separator in the template string.\n * @returns A MaskitoPreprocessor function.\n */\nexport const makeZeroShortcutPreprocessor: (\n  templateString: string,\n  separator: string,\n) => MaskitoPreprocessor = (templateString, separator) => {\n  const zeroShortcutPreprocessor: MaskitoPreprocessor = (\n    { elementState, data },\n    actionType,\n  ) => {\n    // Only process when user is inserting a separator character\n    if (\n      actionType === \"insert\" && // the user is inserting a character\n      data === separator && // the user typed the separator character\n      elementState.selection[0] === elementState.selection[1] // only entering a single character\n    ) {\n      const selectionIndex = elementState.selection[0];\n\n      // Find all separator positions in the template AFTER the current cursor position\n      // This helps us determine the boundaries of the current segment\n      const separatorPositions: number[] = templateString\n        .split(\"\")\n        .map((char, index) => (char === separator ? index : null))\n        .filter((position) => position !== null)\n        .filter((position) => position > selectionIndex);\n\n      // Early exit conditions - don't apply zero padding in these cases\n      const noRemainingSegments = !separatorPositions.length;\n      const nothingEnteredYet = !elementState.value.length;\n      const previousCharacterIsNotADigit = !/^\\d$/.test(\n        elementState.value.slice(-1),\n      );\n      const currentCharacterIsSeparator =\n        templateString[selectionIndex] === separator;\n\n      if (\n        noRemainingSegments ||\n        nothingEnteredYet ||\n        previousCharacterIsNotADigit ||\n        currentCharacterIsSeparator\n      ) {\n        return { elementState, data };\n      }\n\n      // Find the start of the current segment by looking for the last separator or space (for date ranges)\n      // This determines where the current number segment begins\n      const firstIndexOfSegment = Math.max(\n        elementState.value.lastIndexOf(separator) + 1,\n        elementState.value.lastIndexOf(\" \") + 1,\n        0,\n      );\n\n      // Find the end of the current segment (next separator position)\n      const lastIndexOfSegment = separatorPositions[0];\n\n      // Extract the digits currently entered in this segment\n      const digitsCurrentlyInSegment =\n        elementState.value.slice(firstIndexOfSegment);\n\n      // Calculate how many digits this segment should have based on the template\n      // e.g., if template is \"dd/mm/yyyy\", the first segment should have 2 digits\n      const targetNumberOfDigitsInSegment = templateString.slice(\n        firstIndexOfSegment,\n        lastIndexOfSegment,\n      ).length;\n\n      // Pad the current segment with leading zeros to reach the target length\n      // e.g., \"1\" becomes \"01\" for a 2-digit segment\n      const newSegment = digitsCurrentlyInSegment.padStart(\n        targetNumberOfDigitsInSegment,\n        \"0\",\n      );\n\n      // Construct the new value by replacing the current segment with the padded version\n      const newValue = `${elementState.value.slice(0, firstIndexOfSegment)}${newSegment}`;\n\n      // Return the updated state with the padded segment and separator\n      // Position cursor after the separator\n      return {\n        elementState: {\n          value: newValue + data,\n          selection: [newValue.length, newValue.length] as SelectionRange,\n        },\n        data,\n      };\n    }\n    // If conditions aren't met, return unchanged state\n    return { elementState, data };\n  };\n  return zeroShortcutPreprocessor;\n};\n"],"names":[],"mappings":"AAWO,MAAM,4BAAA,GAGc,CAAC,cAAA,EAAgB,SAAA,KAAc;AACxD,EAAA,MAAM,2BAAgD,CACpD,EAAE,YAAA,EAAc,IAAA,IAChB,UAAA,KACG;AAEH,IAAA,IACE,UAAA,KAAe,QAAA;AAAA,IACf,IAAA,KAAS,SAAA;AAAA,IACT,aAAa,SAAA,CAAU,CAAC,MAAM,YAAA,CAAa,SAAA,CAAU,CAAC,CAAA,EACtD;AACA,MAAA,MAAM,cAAA,GAAiB,YAAA,CAAa,SAAA,CAAU,CAAC,CAAA;AAI/C,MAAA,MAAM,kBAAA,GAA+B,cAAA,CAClC,KAAA,CAAM,EAAE,CAAA,CACR,IAAI,CAAC,IAAA,EAAM,KAAA,KAAW,IAAA,KAAS,SAAA,GAAY,KAAA,GAAQ,IAAK,CAAA,CACxD,MAAA,CAAO,CAAC,QAAA,KAAa,QAAA,KAAa,IAAI,EACtC,MAAA,CAAO,CAAC,QAAA,KAAa,QAAA,GAAW,cAAc,CAAA;AAGjD,MAAA,MAAM,mBAAA,GAAsB,CAAC,kBAAA,CAAmB,MAAA;AAChD,MAAA,MAAM,iBAAA,GAAoB,CAAC,YAAA,CAAa,KAAA,CAAM,MAAA;AAC9C,MAAA,MAAM,4BAAA,GAA+B,CAAC,MAAA,CAAO,IAAA;AAAA,QAC3C,YAAA,CAAa,KAAA,CAAM,KAAA,CAAM,EAAE;AAAA,OAC7B;AACA,MAAA,MAAM,2BAAA,GACJ,cAAA,CAAe,cAAc,CAAA,KAAM,SAAA;AAErC,MAAA,IACE,mBAAA,IACA,iBAAA,IACA,4BAAA,IACA,2BAAA,EACA;AACA,QAAA,OAAO,EAAE,cAAc,IAAA,EAAK;AAAA,MAC9B;AAIA,MAAA,MAAM,sBAAsB,IAAA,CAAK,GAAA;AAAA,QAC/B,YAAA,CAAa,KAAA,CAAM,WAAA,CAAY,SAAS,CAAA,GAAI,CAAA;AAAA,QAC5C,YAAA,CAAa,KAAA,CAAM,WAAA,CAAY,GAAG,CAAA,GAAI,CAAA;AAAA,QACtC;AAAA,OACF;AAGA,MAAA,MAAM,kBAAA,GAAqB,mBAAmB,CAAC,CAAA;AAG/C,MAAA,MAAM,wBAAA,GACJ,YAAA,CAAa,KAAA,CAAM,KAAA,CAAM,mBAAmB,CAAA;AAI9C,MAAA,MAAM,gCAAgC,cAAA,CAAe,KAAA;AAAA,QACnD,mBAAA;AAAA,QACA;AAAA,OACF,CAAE,MAAA;AAIF,MAAA,MAAM,aAAa,wBAAA,CAAyB,QAAA;AAAA,QAC1C,6BAAA;AAAA,QACA;AAAA,OACF;AAGA,MAAA,MAAM,QAAA,GAAW,GAAG,YAAA,CAAa,KAAA,CAAM,MAAM,CAAA,EAAG,mBAAmB,CAAC,CAAA,EAAG,UAAU,CAAA,CAAA;AAIjF,MAAA,OAAO;AAAA,QACL,YAAA,EAAc;AAAA,UACZ,OAAO,QAAA,GAAW,IAAA;AAAA,UAClB,SAAA,EAAW,CAAC,QAAA,CAAS,MAAA,EAAQ,SAAS,MAAM;AAAA,SAC9C;AAAA,QACA;AAAA,OACF;AAAA,IACF;AAEA,IAAA,OAAO,EAAE,cAAc,IAAA,EAAK;AAAA,EAC9B,CAAA;AACA,EAAA,OAAO,wBAAA;AACT;;;;"}